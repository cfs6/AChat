// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.File.proto

#ifndef PROTOBUF_IM_2eFile_2eproto__INCLUDED
#define PROTOBUF_IM_2eFile_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "IM.BaseDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace IM {
namespace File {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_IM_2eFile_2eproto();
void protobuf_AssignDesc_IM_2eFile_2eproto();
void protobuf_ShutdownFile_IM_2eFile_2eproto();

class IMFileAddOfflineReq;
class IMFileDelOfflineReq;
class IMFileHasOfflineReq;
class IMFileHasOfflineRsp;
class IMFileLoginReq;
class IMFileLoginRsp;
class IMFileNotify;
class IMFilePullDataReq;
class IMFilePullDataRsp;
class IMFileReq;
class IMFileRsp;
class IMFileState;

// ===================================================================

class IMFileLoginReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileLoginReq) */ {
 public:
  IMFileLoginReq();
  virtual ~IMFileLoginReq();

  IMFileLoginReq(const IMFileLoginReq& from);

  inline IMFileLoginReq& operator=(const IMFileLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const IMFileLoginReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMFileLoginReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMFileLoginReq* other);

  // implements Message ----------------------------------------------

  inline IMFileLoginReq* New() const { return New(NULL); }

  IMFileLoginReq* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileLoginReq& from);
  void MergeFrom(const IMFileLoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileLoginReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // required string task_id = 2;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // required .IM.BaseDefine.ClientFileRole file_role = 3;
  bool has_file_role() const;
  void clear_file_role();
  static const int kFileRoleFieldNumber = 3;
  ::IM::BaseDefine::ClientFileRole file_role() const;
  void set_file_role(::IM::BaseDefine::ClientFileRole value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileLoginReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_file_role();
  inline void clear_has_file_role();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 user_id_;
  int file_role_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eFile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();

  void InitAsDefaultInstance();
  static IMFileLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class IMFileLoginRsp : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileLoginRsp) */ {
 public:
  IMFileLoginRsp();
  virtual ~IMFileLoginRsp();

  IMFileLoginRsp(const IMFileLoginRsp& from);

  inline IMFileLoginRsp& operator=(const IMFileLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const IMFileLoginRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMFileLoginRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMFileLoginRsp* other);

  // implements Message ----------------------------------------------

  inline IMFileLoginRsp* New() const { return New(NULL); }

  IMFileLoginRsp* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileLoginRsp& from);
  void MergeFrom(const IMFileLoginRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileLoginRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result_code = 1;
  bool has_result_code() const;
  void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  ::google::protobuf::uint32 result_code() const;
  void set_result_code(::google::protobuf::uint32 value);

  // required string task_id = 2;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileLoginRsp)
 private:
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_task_id();
  inline void clear_has_task_id();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 result_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eFile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();

  void InitAsDefaultInstance();
  static IMFileLoginRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMFileState : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileState) */ {
 public:
  IMFileState();
  virtual ~IMFileState();

  IMFileState(const IMFileState& from);

  inline IMFileState& operator=(const IMFileState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const IMFileState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMFileState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMFileState* other);

  // implements Message ----------------------------------------------

  inline IMFileState* New() const { return New(NULL); }

  IMFileState* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileState& from);
  void MergeFrom(const IMFileState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.BaseDefine.ClientFileState state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::IM::BaseDefine::ClientFileState state() const;
  void set_state(::IM::BaseDefine::ClientFileState value);

  // required string task_id = 2;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // required uint32 user_id = 3;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileState)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  int state_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eFile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();

  void InitAsDefaultInstance();
  static IMFileState* default_instance_;
};
// -------------------------------------------------------------------

class IMFilePullDataReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFilePullDataReq) */ {
 public:
  IMFilePullDataReq();
  virtual ~IMFilePullDataReq();

  IMFilePullDataReq(const IMFilePullDataReq& from);

  inline IMFilePullDataReq& operator=(const IMFilePullDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const IMFilePullDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMFilePullDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMFilePullDataReq* other);

  // implements Message ----------------------------------------------

  inline IMFilePullDataReq* New() const { return New(NULL); }

  IMFilePullDataReq* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFilePullDataReq& from);
  void MergeFrom(const IMFilePullDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFilePullDataReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string task_id = 1;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // required uint32 user_id = 2;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.TransferFileType trans_mode = 3;
  bool has_trans_mode() const;
  void clear_trans_mode();
  static const int kTransModeFieldNumber = 3;
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);

  // required uint32 offset = 4;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // required uint32 data_size = 5;
  bool has_data_size() const;
  void clear_data_size();
  static const int kDataSizeFieldNumber = 5;
  ::google::protobuf::uint32 data_size() const;
  void set_data_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFilePullDataReq)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_trans_mode();
  inline void clear_has_trans_mode();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_data_size();
  inline void clear_has_data_size();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 user_id_;
  int trans_mode_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 data_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eFile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();

  void InitAsDefaultInstance();
  static IMFilePullDataReq* default_instance_;
};
// -------------------------------------------------------------------

class IMFilePullDataRsp : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFilePullDataRsp) */ {
 public:
  IMFilePullDataRsp();
  virtual ~IMFilePullDataRsp();

  IMFilePullDataRsp(const IMFilePullDataRsp& from);

  inline IMFilePullDataRsp& operator=(const IMFilePullDataRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const IMFilePullDataRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMFilePullDataRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMFilePullDataRsp* other);

  // implements Message ----------------------------------------------

  inline IMFilePullDataRsp* New() const { return New(NULL); }

  IMFilePullDataRsp* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFilePullDataRsp& from);
  void MergeFrom(const IMFilePullDataRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFilePullDataRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result_code = 1;
  bool has_result_code() const;
  void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  ::google::protobuf::uint32 result_code() const;
  void set_result_code(::google::protobuf::uint32 value);

  // required string task_id = 2;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // required uint32 user_id = 3;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // required uint32 offset = 4;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // required bytes file_data = 5;
  bool has_file_data() const;
  void clear_file_data();
  static const int kFileDataFieldNumber = 5;
  const ::std::string& file_data() const;
  void set_file_data(const ::std::string& value);
  void set_file_data(const char* value);
  void set_file_data(const void* value, size_t size);
  ::std::string* mutable_file_data();
  ::std::string* release_file_data();
  void set_allocated_file_data(::std::string* file_data);

  // @@protoc_insertion_point(class_scope:IM.File.IMFilePullDataRsp)
 private:
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_file_data();
  inline void clear_has_file_data();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::internal::ArenaStringPtr file_data_;
  ::google::protobuf::uint32 offset_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eFile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();

  void InitAsDefaultInstance();
  static IMFilePullDataRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMFileReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileReq) */ {
 public:
  IMFileReq();
  virtual ~IMFileReq();

  IMFileReq(const IMFileReq& from);

  inline IMFileReq& operator=(const IMFileReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const IMFileReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMFileReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMFileReq* other);

  // implements Message ----------------------------------------------

  inline IMFileReq* New() const { return New(NULL); }

  IMFileReq* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileReq& from);
  void MergeFrom(const IMFileReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 from_user_id = 1;
  bool has_from_user_id() const;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // required uint32 to_user_id = 2;
  bool has_to_user_id() const;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // required string file_name = 3;
  bool has_file_name() const;
  void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // required uint32 file_size = 4;
  bool has_file_size() const;
  void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  ::google::protobuf::uint32 file_size() const;
  void set_file_size(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.TransferFileType trans_mode = 5;
  bool has_trans_mode() const;
  void clear_trans_mode();
  static const int kTransModeFieldNumber = 5;
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileReq)
 private:
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_to_user_id();
  inline void clear_has_to_user_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_trans_mode();
  inline void clear_has_trans_mode();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::uint32 file_size_;
  int trans_mode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eFile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();

  void InitAsDefaultInstance();
  static IMFileReq* default_instance_;
};
// -------------------------------------------------------------------

class IMFileRsp : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileRsp) */ {
 public:
  IMFileRsp();
  virtual ~IMFileRsp();

  IMFileRsp(const IMFileRsp& from);

  inline IMFileRsp& operator=(const IMFileRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const IMFileRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMFileRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMFileRsp* other);

  // implements Message ----------------------------------------------

  inline IMFileRsp* New() const { return New(NULL); }

  IMFileRsp* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileRsp& from);
  void MergeFrom(const IMFileRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result_code = 1;
  bool has_result_code() const;
  void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  ::google::protobuf::uint32 result_code() const;
  void set_result_code(::google::protobuf::uint32 value);

  // required uint32 from_user_id = 2;
  bool has_from_user_id() const;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 2;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // required uint32 to_user_id = 3;
  bool has_to_user_id() const;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 3;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // required string file_name = 4;
  bool has_file_name() const;
  void clear_file_name();
  static const int kFileNameFieldNumber = 4;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // required string task_id = 5;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 5;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
  int ip_addr_list_size() const;
  void clear_ip_addr_list();
  static const int kIpAddrListFieldNumber = 6;
  const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;

  // required .IM.BaseDefine.TransferFileType trans_mode = 7;
  bool has_trans_mode() const;
  void clear_trans_mode();
  static const int kTransModeFieldNumber = 7;
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileRsp)
 private:
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_to_user_id();
  inline void clear_has_to_user_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_trans_mode();
  inline void clear_has_trans_mode();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 to_user_id_;
  int trans_mode_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eFile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();

  void InitAsDefaultInstance();
  static IMFileRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMFileNotify : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileNotify) */ {
 public:
  IMFileNotify();
  virtual ~IMFileNotify();

  IMFileNotify(const IMFileNotify& from);

  inline IMFileNotify& operator=(const IMFileNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const IMFileNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMFileNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMFileNotify* other);

  // implements Message ----------------------------------------------

  inline IMFileNotify* New() const { return New(NULL); }

  IMFileNotify* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileNotify& from);
  void MergeFrom(const IMFileNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 from_user_id = 1;
  bool has_from_user_id() const;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // required uint32 to_user_id = 2;
  bool has_to_user_id() const;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // required string file_name = 3;
  bool has_file_name() const;
  void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // required uint32 file_size = 4;
  bool has_file_size() const;
  void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  ::google::protobuf::uint32 file_size() const;
  void set_file_size(::google::protobuf::uint32 value);

  // required string task_id = 5;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 5;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
  int ip_addr_list_size() const;
  void clear_ip_addr_list();
  static const int kIpAddrListFieldNumber = 6;
  const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;

  // required .IM.BaseDefine.TransferFileType trans_mode = 7;
  bool has_trans_mode() const;
  void clear_trans_mode();
  static const int kTransModeFieldNumber = 7;
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);

  // required uint32 offline_ready = 8;
  bool has_offline_ready() const;
  void clear_offline_ready();
  static const int kOfflineReadyFieldNumber = 8;
  ::google::protobuf::uint32 offline_ready() const;
  void set_offline_ready(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileNotify)
 private:
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_to_user_id();
  inline void clear_has_to_user_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_trans_mode();
  inline void clear_has_trans_mode();
  inline void set_has_offline_ready();
  inline void clear_has_offline_ready();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 file_size_;
  int trans_mode_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  ::google::protobuf::uint32 offline_ready_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eFile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();

  void InitAsDefaultInstance();
  static IMFileNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMFileHasOfflineReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileHasOfflineReq) */ {
 public:
  IMFileHasOfflineReq();
  virtual ~IMFileHasOfflineReq();

  IMFileHasOfflineReq(const IMFileHasOfflineReq& from);

  inline IMFileHasOfflineReq& operator=(const IMFileHasOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const IMFileHasOfflineReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMFileHasOfflineReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMFileHasOfflineReq* other);

  // implements Message ----------------------------------------------

  inline IMFileHasOfflineReq* New() const { return New(NULL); }

  IMFileHasOfflineReq* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileHasOfflineReq& from);
  void MergeFrom(const IMFileHasOfflineReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileHasOfflineReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  const ::std::string& attach_data() const;
  void set_attach_data(const ::std::string& value);
  void set_attach_data(const char* value);
  void set_attach_data(const void* value, size_t size);
  ::std::string* mutable_attach_data();
  ::std::string* release_attach_data();
  void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileHasOfflineReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eFile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();

  void InitAsDefaultInstance();
  static IMFileHasOfflineReq* default_instance_;
};
// -------------------------------------------------------------------

class IMFileHasOfflineRsp : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileHasOfflineRsp) */ {
 public:
  IMFileHasOfflineRsp();
  virtual ~IMFileHasOfflineRsp();

  IMFileHasOfflineRsp(const IMFileHasOfflineRsp& from);

  inline IMFileHasOfflineRsp& operator=(const IMFileHasOfflineRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const IMFileHasOfflineRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMFileHasOfflineRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMFileHasOfflineRsp* other);

  // implements Message ----------------------------------------------

  inline IMFileHasOfflineRsp* New() const { return New(NULL); }

  IMFileHasOfflineRsp* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileHasOfflineRsp& from);
  void MergeFrom(const IMFileHasOfflineRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileHasOfflineRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.OfflineFileInfo offline_file_list = 2;
  int offline_file_list_size() const;
  void clear_offline_file_list();
  static const int kOfflineFileListFieldNumber = 2;
  const ::IM::BaseDefine::OfflineFileInfo& offline_file_list(int index) const;
  ::IM::BaseDefine::OfflineFileInfo* mutable_offline_file_list(int index);
  ::IM::BaseDefine::OfflineFileInfo* add_offline_file_list();
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >*
      mutable_offline_file_list();
  const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >&
      offline_file_list() const;

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 3;
  int ip_addr_list_size() const;
  void clear_ip_addr_list();
  static const int kIpAddrListFieldNumber = 3;
  const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  const ::std::string& attach_data() const;
  void set_attach_data(const ::std::string& value);
  void set_attach_data(const char* value);
  void set_attach_data(const void* value, size_t size);
  ::std::string* mutable_attach_data();
  ::std::string* release_attach_data();
  void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileHasOfflineRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo > offline_file_list_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  ::google::protobuf::internal::ArenaStringPtr attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eFile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();

  void InitAsDefaultInstance();
  static IMFileHasOfflineRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMFileAddOfflineReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileAddOfflineReq) */ {
 public:
  IMFileAddOfflineReq();
  virtual ~IMFileAddOfflineReq();

  IMFileAddOfflineReq(const IMFileAddOfflineReq& from);

  inline IMFileAddOfflineReq& operator=(const IMFileAddOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const IMFileAddOfflineReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMFileAddOfflineReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMFileAddOfflineReq* other);

  // implements Message ----------------------------------------------

  inline IMFileAddOfflineReq* New() const { return New(NULL); }

  IMFileAddOfflineReq* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileAddOfflineReq& from);
  void MergeFrom(const IMFileAddOfflineReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileAddOfflineReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 from_user_id = 1;
  bool has_from_user_id() const;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // required uint32 to_user_id = 2;
  bool has_to_user_id() const;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // required string task_id = 3;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // required string file_name = 4;
  bool has_file_name() const;
  void clear_file_name();
  static const int kFileNameFieldNumber = 4;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // required uint32 file_size = 5;
  bool has_file_size() const;
  void clear_file_size();
  static const int kFileSizeFieldNumber = 5;
  ::google::protobuf::uint32 file_size() const;
  void set_file_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileAddOfflineReq)
 private:
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_to_user_id();
  inline void clear_has_to_user_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_size();
  inline void clear_has_file_size();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::uint32 file_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eFile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();

  void InitAsDefaultInstance();
  static IMFileAddOfflineReq* default_instance_;
};
// -------------------------------------------------------------------

class IMFileDelOfflineReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileDelOfflineReq) */ {
 public:
  IMFileDelOfflineReq();
  virtual ~IMFileDelOfflineReq();

  IMFileDelOfflineReq(const IMFileDelOfflineReq& from);

  inline IMFileDelOfflineReq& operator=(const IMFileDelOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const IMFileDelOfflineReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMFileDelOfflineReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMFileDelOfflineReq* other);

  // implements Message ----------------------------------------------

  inline IMFileDelOfflineReq* New() const { return New(NULL); }

  IMFileDelOfflineReq* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileDelOfflineReq& from);
  void MergeFrom(const IMFileDelOfflineReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileDelOfflineReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 from_user_id = 1;
  bool has_from_user_id() const;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // required uint32 to_user_id = 2;
  bool has_to_user_id() const;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // required string task_id = 3;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileDelOfflineReq)
 private:
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_to_user_id();
  inline void clear_has_to_user_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eFile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();

  void InitAsDefaultInstance();
  static IMFileDelOfflineReq* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// IMFileLoginReq

// required uint32 user_id = 1;
inline bool IMFileLoginReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileLoginReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileLoginReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileLoginReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFileLoginReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginReq.user_id)
  return user_id_;
}
inline void IMFileLoginReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginReq.user_id)
}

// required string task_id = 2;
inline bool IMFileLoginReq::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileLoginReq::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileLoginReq::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileLoginReq::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFileLoginReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginReq.task_id)
  return task_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileLoginReq::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginReq.task_id)
}
inline void IMFileLoginReq::set_task_id(const char* value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileLoginReq.task_id)
}
inline void IMFileLoginReq::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileLoginReq.task_id)
}
inline ::std::string* IMFileLoginReq::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileLoginReq.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileLoginReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileLoginReq.task_id)
  clear_has_task_id();
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileLoginReq::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileLoginReq.task_id)
}

// required .IM.BaseDefine.ClientFileRole file_role = 3;
inline bool IMFileLoginReq::has_file_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileLoginReq::set_has_file_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileLoginReq::clear_has_file_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileLoginReq::clear_file_role() {
  file_role_ = 1;
  clear_has_file_role();
}
inline ::IM::BaseDefine::ClientFileRole IMFileLoginReq::file_role() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginReq.file_role)
  return static_cast< ::IM::BaseDefine::ClientFileRole >(file_role_);
}
inline void IMFileLoginReq::set_file_role(::IM::BaseDefine::ClientFileRole value) {
  assert(::IM::BaseDefine::ClientFileRole_IsValid(value));
  set_has_file_role();
  file_role_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginReq.file_role)
}

// -------------------------------------------------------------------

// IMFileLoginRsp

// required uint32 result_code = 1;
inline bool IMFileLoginRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileLoginRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileLoginRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileLoginRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMFileLoginRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginRsp.result_code)
  return result_code_;
}
inline void IMFileLoginRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginRsp.result_code)
}

// required string task_id = 2;
inline bool IMFileLoginRsp::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileLoginRsp::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileLoginRsp::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileLoginRsp::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFileLoginRsp::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginRsp.task_id)
  return task_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileLoginRsp::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginRsp.task_id)
}
inline void IMFileLoginRsp::set_task_id(const char* value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileLoginRsp.task_id)
}
inline void IMFileLoginRsp::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileLoginRsp.task_id)
}
inline ::std::string* IMFileLoginRsp::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileLoginRsp.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileLoginRsp::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileLoginRsp.task_id)
  clear_has_task_id();
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileLoginRsp::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileLoginRsp.task_id)
}

// -------------------------------------------------------------------

// IMFileState

// required .IM.BaseDefine.ClientFileState state = 1;
inline bool IMFileState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::IM::BaseDefine::ClientFileState IMFileState::state() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileState.state)
  return static_cast< ::IM::BaseDefine::ClientFileState >(state_);
}
inline void IMFileState::set_state(::IM::BaseDefine::ClientFileState value) {
  assert(::IM::BaseDefine::ClientFileState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileState.state)
}

// required string task_id = 2;
inline bool IMFileState::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileState::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileState::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileState::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFileState::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileState.task_id)
  return task_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileState::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileState.task_id)
}
inline void IMFileState::set_task_id(const char* value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileState.task_id)
}
inline void IMFileState::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileState.task_id)
}
inline ::std::string* IMFileState::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileState.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileState::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileState.task_id)
  clear_has_task_id();
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileState::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileState.task_id)
}

// required uint32 user_id = 3;
inline bool IMFileState::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileState::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileState::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileState::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFileState::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileState.user_id)
  return user_id_;
}
inline void IMFileState::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileState.user_id)
}

// -------------------------------------------------------------------

// IMFilePullDataReq

// required string task_id = 1;
inline bool IMFilePullDataReq::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFilePullDataReq::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFilePullDataReq::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFilePullDataReq::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFilePullDataReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.task_id)
  return task_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFilePullDataReq::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.task_id)
}
inline void IMFilePullDataReq::set_task_id(const char* value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFilePullDataReq.task_id)
}
inline void IMFilePullDataReq::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFilePullDataReq.task_id)
}
inline ::std::string* IMFilePullDataReq::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFilePullDataReq.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFilePullDataReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFilePullDataReq.task_id)
  clear_has_task_id();
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFilePullDataReq::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFilePullDataReq.task_id)
}

// required uint32 user_id = 2;
inline bool IMFilePullDataReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFilePullDataReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFilePullDataReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFilePullDataReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFilePullDataReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.user_id)
  return user_id_;
}
inline void IMFilePullDataReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.user_id)
}

// required .IM.BaseDefine.TransferFileType trans_mode = 3;
inline bool IMFilePullDataReq::has_trans_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFilePullDataReq::set_has_trans_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFilePullDataReq::clear_has_trans_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFilePullDataReq::clear_trans_mode() {
  trans_mode_ = 1;
  clear_has_trans_mode();
}
inline ::IM::BaseDefine::TransferFileType IMFilePullDataReq::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.trans_mode)
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline void IMFilePullDataReq::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  assert(::IM::BaseDefine::TransferFileType_IsValid(value));
  set_has_trans_mode();
  trans_mode_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.trans_mode)
}

// required uint32 offset = 4;
inline bool IMFilePullDataReq::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFilePullDataReq::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFilePullDataReq::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFilePullDataReq::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 IMFilePullDataReq::offset() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.offset)
  return offset_;
}
inline void IMFilePullDataReq::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.offset)
}

// required uint32 data_size = 5;
inline bool IMFilePullDataReq::has_data_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFilePullDataReq::set_has_data_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFilePullDataReq::clear_has_data_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFilePullDataReq::clear_data_size() {
  data_size_ = 0u;
  clear_has_data_size();
}
inline ::google::protobuf::uint32 IMFilePullDataReq::data_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.data_size)
  return data_size_;
}
inline void IMFilePullDataReq::set_data_size(::google::protobuf::uint32 value) {
  set_has_data_size();
  data_size_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.data_size)
}

// -------------------------------------------------------------------

// IMFilePullDataRsp

// required uint32 result_code = 1;
inline bool IMFilePullDataRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFilePullDataRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFilePullDataRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFilePullDataRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMFilePullDataRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.result_code)
  return result_code_;
}
inline void IMFilePullDataRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.result_code)
}

// required string task_id = 2;
inline bool IMFilePullDataRsp::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFilePullDataRsp::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFilePullDataRsp::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFilePullDataRsp::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFilePullDataRsp::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.task_id)
  return task_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFilePullDataRsp::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.task_id)
}
inline void IMFilePullDataRsp::set_task_id(const char* value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFilePullDataRsp.task_id)
}
inline void IMFilePullDataRsp::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFilePullDataRsp.task_id)
}
inline ::std::string* IMFilePullDataRsp::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFilePullDataRsp.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFilePullDataRsp::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFilePullDataRsp.task_id)
  clear_has_task_id();
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFilePullDataRsp::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFilePullDataRsp.task_id)
}

// required uint32 user_id = 3;
inline bool IMFilePullDataRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFilePullDataRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFilePullDataRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFilePullDataRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFilePullDataRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.user_id)
  return user_id_;
}
inline void IMFilePullDataRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.user_id)
}

// required uint32 offset = 4;
inline bool IMFilePullDataRsp::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFilePullDataRsp::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFilePullDataRsp::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFilePullDataRsp::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 IMFilePullDataRsp::offset() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.offset)
  return offset_;
}
inline void IMFilePullDataRsp::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.offset)
}

// required bytes file_data = 5;
inline bool IMFilePullDataRsp::has_file_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFilePullDataRsp::set_has_file_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFilePullDataRsp::clear_has_file_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFilePullDataRsp::clear_file_data() {
  file_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_data();
}
inline const ::std::string& IMFilePullDataRsp::file_data() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.file_data)
  return file_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFilePullDataRsp::set_file_data(const ::std::string& value) {
  set_has_file_data();
  file_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.file_data)
}
inline void IMFilePullDataRsp::set_file_data(const char* value) {
  set_has_file_data();
  file_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFilePullDataRsp.file_data)
}
inline void IMFilePullDataRsp::set_file_data(const void* value, size_t size) {
  set_has_file_data();
  file_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFilePullDataRsp.file_data)
}
inline ::std::string* IMFilePullDataRsp::mutable_file_data() {
  set_has_file_data();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFilePullDataRsp.file_data)
  return file_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFilePullDataRsp::release_file_data() {
  // @@protoc_insertion_point(field_release:IM.File.IMFilePullDataRsp.file_data)
  clear_has_file_data();
  return file_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFilePullDataRsp::set_allocated_file_data(::std::string* file_data) {
  if (file_data != NULL) {
    set_has_file_data();
  } else {
    clear_has_file_data();
  }
  file_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_data);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFilePullDataRsp.file_data)
}

// -------------------------------------------------------------------

// IMFileReq

// required uint32 from_user_id = 1;
inline bool IMFileReq::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileReq::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileReq::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileReq::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileReq::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.from_user_id)
  return from_user_id_;
}
inline void IMFileReq::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.from_user_id)
}

// required uint32 to_user_id = 2;
inline bool IMFileReq::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileReq::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileReq::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileReq::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileReq::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.to_user_id)
  return to_user_id_;
}
inline void IMFileReq::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.to_user_id)
}

// required string file_name = 3;
inline bool IMFileReq::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileReq::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileReq::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileReq::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
inline const ::std::string& IMFileReq::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileReq::set_file_name(const ::std::string& value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.file_name)
}
inline void IMFileReq::set_file_name(const char* value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileReq.file_name)
}
inline void IMFileReq::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileReq.file_name)
}
inline ::std::string* IMFileReq::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileReq.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileReq::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileReq.file_name)
  clear_has_file_name();
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileReq::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileReq.file_name)
}

// required uint32 file_size = 4;
inline bool IMFileReq::has_file_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFileReq::set_has_file_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFileReq::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFileReq::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 IMFileReq::file_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.file_size)
  return file_size_;
}
inline void IMFileReq::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.file_size)
}

// required .IM.BaseDefine.TransferFileType trans_mode = 5;
inline bool IMFileReq::has_trans_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFileReq::set_has_trans_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFileReq::clear_has_trans_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFileReq::clear_trans_mode() {
  trans_mode_ = 1;
  clear_has_trans_mode();
}
inline ::IM::BaseDefine::TransferFileType IMFileReq::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.trans_mode)
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline void IMFileReq::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  assert(::IM::BaseDefine::TransferFileType_IsValid(value));
  set_has_trans_mode();
  trans_mode_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.trans_mode)
}

// -------------------------------------------------------------------

// IMFileRsp

// required uint32 result_code = 1;
inline bool IMFileRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMFileRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.result_code)
  return result_code_;
}
inline void IMFileRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.result_code)
}

// required uint32 from_user_id = 2;
inline bool IMFileRsp::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileRsp::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileRsp::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileRsp::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileRsp::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.from_user_id)
  return from_user_id_;
}
inline void IMFileRsp::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.from_user_id)
}

// required uint32 to_user_id = 3;
inline bool IMFileRsp::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileRsp::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileRsp::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileRsp::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileRsp::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.to_user_id)
  return to_user_id_;
}
inline void IMFileRsp::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.to_user_id)
}

// required string file_name = 4;
inline bool IMFileRsp::has_file_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFileRsp::set_has_file_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFileRsp::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFileRsp::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
inline const ::std::string& IMFileRsp::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileRsp::set_file_name(const ::std::string& value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.file_name)
}
inline void IMFileRsp::set_file_name(const char* value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileRsp.file_name)
}
inline void IMFileRsp::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileRsp.file_name)
}
inline ::std::string* IMFileRsp::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileRsp.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileRsp::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileRsp.file_name)
  clear_has_file_name();
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileRsp::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileRsp.file_name)
}

// required string task_id = 5;
inline bool IMFileRsp::has_task_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFileRsp::set_has_task_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFileRsp::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFileRsp::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFileRsp::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.task_id)
  return task_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileRsp::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.task_id)
}
inline void IMFileRsp::set_task_id(const char* value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileRsp.task_id)
}
inline void IMFileRsp::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileRsp.task_id)
}
inline ::std::string* IMFileRsp::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileRsp.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileRsp::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileRsp.task_id)
  clear_has_task_id();
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileRsp::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileRsp.task_id)
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
inline int IMFileRsp::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline void IMFileRsp::clear_ip_addr_list() {
  ip_addr_list_.Clear();
}
inline const ::IM::BaseDefine::IpAddr& IMFileRsp::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.ip_addr_list)
  return ip_addr_list_.Get(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileRsp::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileRsp.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileRsp::add_ip_addr_list() {
  // @@protoc_insertion_point(field_add:IM.File.IMFileRsp.ip_addr_list)
  return ip_addr_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileRsp::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileRsp.ip_addr_list)
  return &ip_addr_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileRsp::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileRsp.ip_addr_list)
  return ip_addr_list_;
}

// required .IM.BaseDefine.TransferFileType trans_mode = 7;
inline bool IMFileRsp::has_trans_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMFileRsp::set_has_trans_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMFileRsp::clear_has_trans_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMFileRsp::clear_trans_mode() {
  trans_mode_ = 1;
  clear_has_trans_mode();
}
inline ::IM::BaseDefine::TransferFileType IMFileRsp::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.trans_mode)
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline void IMFileRsp::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  assert(::IM::BaseDefine::TransferFileType_IsValid(value));
  set_has_trans_mode();
  trans_mode_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.trans_mode)
}

// -------------------------------------------------------------------

// IMFileNotify

// required uint32 from_user_id = 1;
inline bool IMFileNotify::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileNotify::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileNotify::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileNotify::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileNotify::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.from_user_id)
  return from_user_id_;
}
inline void IMFileNotify::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.from_user_id)
}

// required uint32 to_user_id = 2;
inline bool IMFileNotify::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileNotify::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileNotify::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileNotify::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileNotify::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.to_user_id)
  return to_user_id_;
}
inline void IMFileNotify::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.to_user_id)
}

// required string file_name = 3;
inline bool IMFileNotify::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileNotify::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileNotify::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileNotify::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
inline const ::std::string& IMFileNotify::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileNotify::set_file_name(const ::std::string& value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.file_name)
}
inline void IMFileNotify::set_file_name(const char* value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileNotify.file_name)
}
inline void IMFileNotify::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileNotify.file_name)
}
inline ::std::string* IMFileNotify::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileNotify.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileNotify::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileNotify.file_name)
  clear_has_file_name();
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileNotify::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileNotify.file_name)
}

// required uint32 file_size = 4;
inline bool IMFileNotify::has_file_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFileNotify::set_has_file_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFileNotify::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFileNotify::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 IMFileNotify::file_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.file_size)
  return file_size_;
}
inline void IMFileNotify::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.file_size)
}

// required string task_id = 5;
inline bool IMFileNotify::has_task_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFileNotify::set_has_task_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFileNotify::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFileNotify::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFileNotify::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.task_id)
  return task_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileNotify::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.task_id)
}
inline void IMFileNotify::set_task_id(const char* value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileNotify.task_id)
}
inline void IMFileNotify::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileNotify.task_id)
}
inline ::std::string* IMFileNotify::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileNotify.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileNotify::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileNotify.task_id)
  clear_has_task_id();
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileNotify::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileNotify.task_id)
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
inline int IMFileNotify::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline void IMFileNotify::clear_ip_addr_list() {
  ip_addr_list_.Clear();
}
inline const ::IM::BaseDefine::IpAddr& IMFileNotify::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.ip_addr_list)
  return ip_addr_list_.Get(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileNotify::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileNotify.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileNotify::add_ip_addr_list() {
  // @@protoc_insertion_point(field_add:IM.File.IMFileNotify.ip_addr_list)
  return ip_addr_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileNotify::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileNotify.ip_addr_list)
  return &ip_addr_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileNotify::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileNotify.ip_addr_list)
  return ip_addr_list_;
}

// required .IM.BaseDefine.TransferFileType trans_mode = 7;
inline bool IMFileNotify::has_trans_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMFileNotify::set_has_trans_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMFileNotify::clear_has_trans_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMFileNotify::clear_trans_mode() {
  trans_mode_ = 1;
  clear_has_trans_mode();
}
inline ::IM::BaseDefine::TransferFileType IMFileNotify::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.trans_mode)
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline void IMFileNotify::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  assert(::IM::BaseDefine::TransferFileType_IsValid(value));
  set_has_trans_mode();
  trans_mode_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.trans_mode)
}

// required uint32 offline_ready = 8;
inline bool IMFileNotify::has_offline_ready() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMFileNotify::set_has_offline_ready() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMFileNotify::clear_has_offline_ready() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMFileNotify::clear_offline_ready() {
  offline_ready_ = 0u;
  clear_has_offline_ready();
}
inline ::google::protobuf::uint32 IMFileNotify::offline_ready() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.offline_ready)
  return offline_ready_;
}
inline void IMFileNotify::set_offline_ready(::google::protobuf::uint32 value) {
  set_has_offline_ready();
  offline_ready_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.offline_ready)
}

// -------------------------------------------------------------------

// IMFileHasOfflineReq

// required uint32 user_id = 1;
inline bool IMFileHasOfflineReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileHasOfflineReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileHasOfflineReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileHasOfflineReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFileHasOfflineReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineReq.user_id)
  return user_id_;
}
inline void IMFileHasOfflineReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineReq.user_id)
}

// optional bytes attach_data = 20;
inline bool IMFileHasOfflineReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileHasOfflineReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileHasOfflineReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileHasOfflineReq::clear_attach_data() {
  attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attach_data();
}
inline const ::std::string& IMFileHasOfflineReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineReq.attach_data)
  return attach_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileHasOfflineReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineReq.attach_data)
}
inline void IMFileHasOfflineReq::set_attach_data(const char* value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileHasOfflineReq.attach_data)
}
inline void IMFileHasOfflineReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileHasOfflineReq.attach_data)
}
inline ::std::string* IMFileHasOfflineReq::mutable_attach_data() {
  set_has_attach_data();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineReq.attach_data)
  return attach_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileHasOfflineReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileHasOfflineReq.attach_data)
  clear_has_attach_data();
  return attach_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileHasOfflineReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data != NULL) {
    set_has_attach_data();
  } else {
    clear_has_attach_data();
  }
  attach_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attach_data);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileHasOfflineReq.attach_data)
}

// -------------------------------------------------------------------

// IMFileHasOfflineRsp

// required uint32 user_id = 1;
inline bool IMFileHasOfflineRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileHasOfflineRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileHasOfflineRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileHasOfflineRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFileHasOfflineRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.user_id)
  return user_id_;
}
inline void IMFileHasOfflineRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineRsp.user_id)
}

// repeated .IM.BaseDefine.OfflineFileInfo offline_file_list = 2;
inline int IMFileHasOfflineRsp::offline_file_list_size() const {
  return offline_file_list_.size();
}
inline void IMFileHasOfflineRsp::clear_offline_file_list() {
  offline_file_list_.Clear();
}
inline const ::IM::BaseDefine::OfflineFileInfo& IMFileHasOfflineRsp::offline_file_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return offline_file_list_.Get(index);
}
inline ::IM::BaseDefine::OfflineFileInfo* IMFileHasOfflineRsp::mutable_offline_file_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return offline_file_list_.Mutable(index);
}
inline ::IM::BaseDefine::OfflineFileInfo* IMFileHasOfflineRsp::add_offline_file_list() {
  // @@protoc_insertion_point(field_add:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return offline_file_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >*
IMFileHasOfflineRsp::mutable_offline_file_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return &offline_file_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >&
IMFileHasOfflineRsp::offline_file_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return offline_file_list_;
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 3;
inline int IMFileHasOfflineRsp::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline void IMFileHasOfflineRsp::clear_ip_addr_list() {
  ip_addr_list_.Clear();
}
inline const ::IM::BaseDefine::IpAddr& IMFileHasOfflineRsp::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return ip_addr_list_.Get(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileHasOfflineRsp::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileHasOfflineRsp::add_ip_addr_list() {
  // @@protoc_insertion_point(field_add:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return ip_addr_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileHasOfflineRsp::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return &ip_addr_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileHasOfflineRsp::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return ip_addr_list_;
}

// optional bytes attach_data = 20;
inline bool IMFileHasOfflineRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFileHasOfflineRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFileHasOfflineRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFileHasOfflineRsp::clear_attach_data() {
  attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attach_data();
}
inline const ::std::string& IMFileHasOfflineRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.attach_data)
  return attach_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileHasOfflineRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineRsp.attach_data)
}
inline void IMFileHasOfflineRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileHasOfflineRsp.attach_data)
}
inline void IMFileHasOfflineRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileHasOfflineRsp.attach_data)
}
inline ::std::string* IMFileHasOfflineRsp::mutable_attach_data() {
  set_has_attach_data();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineRsp.attach_data)
  return attach_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileHasOfflineRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileHasOfflineRsp.attach_data)
  clear_has_attach_data();
  return attach_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileHasOfflineRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data != NULL) {
    set_has_attach_data();
  } else {
    clear_has_attach_data();
  }
  attach_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attach_data);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileHasOfflineRsp.attach_data)
}

// -------------------------------------------------------------------

// IMFileAddOfflineReq

// required uint32 from_user_id = 1;
inline bool IMFileAddOfflineReq::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileAddOfflineReq::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileAddOfflineReq::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileAddOfflineReq::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileAddOfflineReq::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.from_user_id)
  return from_user_id_;
}
inline void IMFileAddOfflineReq::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.from_user_id)
}

// required uint32 to_user_id = 2;
inline bool IMFileAddOfflineReq::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileAddOfflineReq::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileAddOfflineReq::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileAddOfflineReq::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileAddOfflineReq::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.to_user_id)
  return to_user_id_;
}
inline void IMFileAddOfflineReq::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.to_user_id)
}

// required string task_id = 3;
inline bool IMFileAddOfflineReq::has_task_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileAddOfflineReq::set_has_task_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileAddOfflineReq::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileAddOfflineReq::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFileAddOfflineReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.task_id)
  return task_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileAddOfflineReq::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.task_id)
}
inline void IMFileAddOfflineReq::set_task_id(const char* value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileAddOfflineReq.task_id)
}
inline void IMFileAddOfflineReq::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileAddOfflineReq.task_id)
}
inline ::std::string* IMFileAddOfflineReq::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileAddOfflineReq.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileAddOfflineReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileAddOfflineReq.task_id)
  clear_has_task_id();
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileAddOfflineReq::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileAddOfflineReq.task_id)
}

// required string file_name = 4;
inline bool IMFileAddOfflineReq::has_file_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFileAddOfflineReq::set_has_file_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFileAddOfflineReq::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFileAddOfflineReq::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
inline const ::std::string& IMFileAddOfflineReq::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileAddOfflineReq::set_file_name(const ::std::string& value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.file_name)
}
inline void IMFileAddOfflineReq::set_file_name(const char* value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileAddOfflineReq.file_name)
}
inline void IMFileAddOfflineReq::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileAddOfflineReq.file_name)
}
inline ::std::string* IMFileAddOfflineReq::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileAddOfflineReq.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileAddOfflineReq::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileAddOfflineReq.file_name)
  clear_has_file_name();
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileAddOfflineReq::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileAddOfflineReq.file_name)
}

// required uint32 file_size = 5;
inline bool IMFileAddOfflineReq::has_file_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFileAddOfflineReq::set_has_file_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFileAddOfflineReq::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFileAddOfflineReq::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 IMFileAddOfflineReq::file_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.file_size)
  return file_size_;
}
inline void IMFileAddOfflineReq::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.file_size)
}

// -------------------------------------------------------------------

// IMFileDelOfflineReq

// required uint32 from_user_id = 1;
inline bool IMFileDelOfflineReq::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileDelOfflineReq::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileDelOfflineReq::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileDelOfflineReq::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileDelOfflineReq::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileDelOfflineReq.from_user_id)
  return from_user_id_;
}
inline void IMFileDelOfflineReq::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileDelOfflineReq.from_user_id)
}

// required uint32 to_user_id = 2;
inline bool IMFileDelOfflineReq::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileDelOfflineReq::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileDelOfflineReq::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileDelOfflineReq::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileDelOfflineReq::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileDelOfflineReq.to_user_id)
  return to_user_id_;
}
inline void IMFileDelOfflineReq::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileDelOfflineReq.to_user_id)
}

// required string task_id = 3;
inline bool IMFileDelOfflineReq::has_task_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileDelOfflineReq::set_has_task_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileDelOfflineReq::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileDelOfflineReq::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFileDelOfflineReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileDelOfflineReq.task_id)
  return task_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileDelOfflineReq::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileDelOfflineReq.task_id)
}
inline void IMFileDelOfflineReq::set_task_id(const char* value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileDelOfflineReq.task_id)
}
inline void IMFileDelOfflineReq::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileDelOfflineReq.task_id)
}
inline ::std::string* IMFileDelOfflineReq::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileDelOfflineReq.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileDelOfflineReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileDelOfflineReq.task_id)
  clear_has_task_id();
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileDelOfflineReq::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileDelOfflineReq.task_id)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace File
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eFile_2eproto__INCLUDED
