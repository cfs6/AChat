// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Server.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "IM.Server.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace Server {

void protobuf_ShutdownFile_IM_2eServer_2eproto() {
  delete IMStopReceivePacket::default_instance_;
  delete IMValidateReq::default_instance_;
  delete IMValidateRsp::default_instance_;
  delete IMGetDeviceTokenReq::default_instance_;
  delete IMGetDeviceTokenRsp::default_instance_;
  delete IMRoleSet::default_instance_;
  delete IMOnlineUserInfo::default_instance_;
  delete IMMsgServInfo::default_instance_;
  delete IMUserStatusUpdate::default_instance_;
  delete IMUserCntUpdate::default_instance_;
  delete IMServerKickUser::default_instance_;
  delete IMServerPCLoginStatusNotify::default_instance_;
  delete IMPushToUserReq::default_instance_;
  delete IMPushToUserRsp::default_instance_;
  delete IMGroupGetShieldReq::default_instance_;
  delete IMGroupGetShieldRsp::default_instance_;
  delete IMFileTransferReq::default_instance_;
  delete IMFileTransferRsp::default_instance_;
  delete IMFileServerIPReq::default_instance_;
  delete IMFileServerIPRsp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_IM_2eServer_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_IM_2eServer_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_IM_2eServer_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::IM::BaseDefine::protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  IMStopReceivePacket::default_instance_ = new IMStopReceivePacket();
  IMValidateReq::default_instance_ = new IMValidateReq();
  IMValidateRsp::default_instance_ = new IMValidateRsp();
  IMGetDeviceTokenReq::default_instance_ = new IMGetDeviceTokenReq();
  IMGetDeviceTokenRsp::default_instance_ = new IMGetDeviceTokenRsp();
  IMRoleSet::default_instance_ = new IMRoleSet();
  IMOnlineUserInfo::default_instance_ = new IMOnlineUserInfo();
  IMMsgServInfo::default_instance_ = new IMMsgServInfo();
  IMUserStatusUpdate::default_instance_ = new IMUserStatusUpdate();
  IMUserCntUpdate::default_instance_ = new IMUserCntUpdate();
  IMServerKickUser::default_instance_ = new IMServerKickUser();
  IMServerPCLoginStatusNotify::default_instance_ = new IMServerPCLoginStatusNotify();
  IMPushToUserReq::default_instance_ = new IMPushToUserReq();
  IMPushToUserRsp::default_instance_ = new IMPushToUserRsp();
  IMGroupGetShieldReq::default_instance_ = new IMGroupGetShieldReq();
  IMGroupGetShieldRsp::default_instance_ = new IMGroupGetShieldRsp();
  IMFileTransferReq::default_instance_ = new IMFileTransferReq();
  IMFileTransferRsp::default_instance_ = new IMFileTransferRsp();
  IMFileServerIPReq::default_instance_ = new IMFileServerIPReq();
  IMFileServerIPRsp::default_instance_ = new IMFileServerIPRsp();
  IMStopReceivePacket::default_instance_->InitAsDefaultInstance();
  IMValidateReq::default_instance_->InitAsDefaultInstance();
  IMValidateRsp::default_instance_->InitAsDefaultInstance();
  IMGetDeviceTokenReq::default_instance_->InitAsDefaultInstance();
  IMGetDeviceTokenRsp::default_instance_->InitAsDefaultInstance();
  IMRoleSet::default_instance_->InitAsDefaultInstance();
  IMOnlineUserInfo::default_instance_->InitAsDefaultInstance();
  IMMsgServInfo::default_instance_->InitAsDefaultInstance();
  IMUserStatusUpdate::default_instance_->InitAsDefaultInstance();
  IMUserCntUpdate::default_instance_->InitAsDefaultInstance();
  IMServerKickUser::default_instance_->InitAsDefaultInstance();
  IMServerPCLoginStatusNotify::default_instance_->InitAsDefaultInstance();
  IMPushToUserReq::default_instance_->InitAsDefaultInstance();
  IMPushToUserRsp::default_instance_->InitAsDefaultInstance();
  IMGroupGetShieldReq::default_instance_->InitAsDefaultInstance();
  IMGroupGetShieldRsp::default_instance_->InitAsDefaultInstance();
  IMFileTransferReq::default_instance_->InitAsDefaultInstance();
  IMFileTransferRsp::default_instance_->InitAsDefaultInstance();
  IMFileServerIPReq::default_instance_->InitAsDefaultInstance();
  IMFileServerIPRsp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_IM_2eServer_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_IM_2eServer_2eproto_once_);
void protobuf_AddDesc_IM_2eServer_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_IM_2eServer_2eproto_once_,
                 &protobuf_AddDesc_IM_2eServer_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_IM_2eServer_2eproto {
  StaticDescriptorInitializer_IM_2eServer_2eproto() {
    protobuf_AddDesc_IM_2eServer_2eproto();
  }
} static_descriptor_initializer_IM_2eServer_2eproto_;
#endif

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMStopReceivePacket(
    IMStopReceivePacket* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMStopReceivePacket::kResultFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMStopReceivePacket::IMStopReceivePacket()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMStopReceivePacket)
}

void IMStopReceivePacket::InitAsDefaultInstance() {
}

IMStopReceivePacket::IMStopReceivePacket(const IMStopReceivePacket& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMStopReceivePacket)
}

void IMStopReceivePacket::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  result_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMStopReceivePacket::~IMStopReceivePacket() {
  // @@protoc_insertion_point(destructor:IM.Server.IMStopReceivePacket)
  SharedDtor();
}

void IMStopReceivePacket::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMStopReceivePacket::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMStopReceivePacket& IMStopReceivePacket::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMStopReceivePacket* IMStopReceivePacket::default_instance_ = NULL;

IMStopReceivePacket* IMStopReceivePacket::New(::google::protobuf::Arena* arena) const {
  IMStopReceivePacket* n = new IMStopReceivePacket;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMStopReceivePacket::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMStopReceivePacket)
  result_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMStopReceivePacket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMStopReceivePacket, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMStopReceivePacket)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 result = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMStopReceivePacket)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMStopReceivePacket)
  return false;
#undef DO_
}

void IMStopReceivePacket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMStopReceivePacket)
  // required uint32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->result(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMStopReceivePacket)
}

int IMStopReceivePacket::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMStopReceivePacket)
  int total_size = 0;

  // required uint32 result = 1;
  if (has_result()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->result());
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMStopReceivePacket::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMStopReceivePacket*>(&from));
}

void IMStopReceivePacket::MergeFrom(const IMStopReceivePacket& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMStopReceivePacket)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMStopReceivePacket::CopyFrom(const IMStopReceivePacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMStopReceivePacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMStopReceivePacket::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMStopReceivePacket::Swap(IMStopReceivePacket* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMStopReceivePacket::InternalSwap(IMStopReceivePacket* other) {
  std::swap(result_, other->result_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMStopReceivePacket::GetTypeName() const {
  return "IM.Server.IMStopReceivePacket";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMStopReceivePacket

// required uint32 result = 1;
bool IMStopReceivePacket::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IMStopReceivePacket::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
void IMStopReceivePacket::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
void IMStopReceivePacket::clear_result() {
  result_ = 0u;
  clear_has_result();
}
 ::google::protobuf::uint32 IMStopReceivePacket::result() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMStopReceivePacket.result)
  return result_;
}
 void IMStopReceivePacket::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMStopReceivePacket.result)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMValidateReq(
    IMValidateReq* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMValidateReq::kUserNameFieldNumber;
const int IMValidateReq::kPasswordFieldNumber;
const int IMValidateReq::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMValidateReq::IMValidateReq()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMValidateReq)
}

void IMValidateReq::InitAsDefaultInstance() {
}

IMValidateReq::IMValidateReq(const IMValidateReq& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMValidateReq)
}

void IMValidateReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMValidateReq::~IMValidateReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMValidateReq)
  SharedDtor();
}

void IMValidateReq::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMValidateReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMValidateReq& IMValidateReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMValidateReq* IMValidateReq::default_instance_ = NULL;

IMValidateReq* IMValidateReq::New(::google::protobuf::Arena* arena) const {
  IMValidateReq* n = new IMValidateReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMValidateReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMValidateReq)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_user_name()) {
      user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_password()) {
      password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_attach_data()) {
      attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMValidateReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMValidateReq, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMValidateReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_password;
        break;
      }

      // required string password = 2;
      case 2: {
        if (tag == 18) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMValidateReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMValidateReq)
  return false;
#undef DO_
}

void IMValidateReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMValidateReq)
  // required string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->user_name(), output);
  }

  // required string password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->password(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMValidateReq)
}

int IMValidateReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMValidateReq)
  int total_size = 0;

  if (has_user_name()) {
    // required string user_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->user_name());
  }

  if (has_password()) {
    // required string password = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->password());
  }

  return total_size;
}
int IMValidateReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMValidateReq)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string user_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->user_name());

    // required string password = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->password());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->attach_data());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMValidateReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMValidateReq*>(&from));
}

void IMValidateReq::MergeFrom(const IMValidateReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMValidateReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_has_user_name();
      user_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_name_);
    }
    if (from.has_password()) {
      set_has_password();
      password_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.password_);
    }
    if (from.has_attach_data()) {
      set_has_attach_data();
      attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMValidateReq::CopyFrom(const IMValidateReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMValidateReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMValidateReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMValidateReq::Swap(IMValidateReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMValidateReq::InternalSwap(IMValidateReq* other) {
  user_name_.Swap(&other->user_name_);
  password_.Swap(&other->password_);
  attach_data_.Swap(&other->attach_data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMValidateReq::GetTypeName() const {
  return "IM.Server.IMValidateReq";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMValidateReq

// required string user_name = 1;
bool IMValidateReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IMValidateReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
void IMValidateReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void IMValidateReq::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_name();
}
 const ::std::string& IMValidateReq::user_name() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMValidateReq.user_name)
  return user_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMValidateReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMValidateReq.user_name)
}
 void IMValidateReq::set_user_name(const char* value) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMValidateReq.user_name)
}
 void IMValidateReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMValidateReq.user_name)
}
 ::std::string* IMValidateReq::mutable_user_name() {
  set_has_user_name();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMValidateReq.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMValidateReq::release_user_name() {
  // @@protoc_insertion_point(field_release:IM.Server.IMValidateReq.user_name)
  clear_has_user_name();
  return user_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMValidateReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    set_has_user_name();
  } else {
    clear_has_user_name();
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMValidateReq.user_name)
}

// required string password = 2;
bool IMValidateReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IMValidateReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
void IMValidateReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
void IMValidateReq::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
 const ::std::string& IMValidateReq::password() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMValidateReq.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMValidateReq::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMValidateReq.password)
}
 void IMValidateReq::set_password(const char* value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMValidateReq.password)
}
 void IMValidateReq::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMValidateReq.password)
}
 ::std::string* IMValidateReq::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMValidateReq.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMValidateReq::release_password() {
  // @@protoc_insertion_point(field_release:IM.Server.IMValidateReq.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMValidateReq::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMValidateReq.password)
}

// optional bytes attach_data = 20;
bool IMValidateReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void IMValidateReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
void IMValidateReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
void IMValidateReq::clear_attach_data() {
  attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attach_data();
}
 const ::std::string& IMValidateReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMValidateReq.attach_data)
  return attach_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMValidateReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMValidateReq.attach_data)
}
 void IMValidateReq::set_attach_data(const char* value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMValidateReq.attach_data)
}
 void IMValidateReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMValidateReq.attach_data)
}
 ::std::string* IMValidateReq::mutable_attach_data() {
  set_has_attach_data();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMValidateReq.attach_data)
  return attach_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMValidateReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.Server.IMValidateReq.attach_data)
  clear_has_attach_data();
  return attach_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMValidateReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data != NULL) {
    set_has_attach_data();
  } else {
    clear_has_attach_data();
  }
  attach_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attach_data);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMValidateReq.attach_data)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMValidateRsp(
    IMValidateRsp* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMValidateRsp::kUserNameFieldNumber;
const int IMValidateRsp::kResultCodeFieldNumber;
const int IMValidateRsp::kResultStringFieldNumber;
const int IMValidateRsp::kUserInfoFieldNumber;
const int IMValidateRsp::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMValidateRsp::IMValidateRsp()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMValidateRsp)
}

void IMValidateRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_info_ = const_cast< ::IM::BaseDefine::UserInfo*>(
      ::IM::BaseDefine::UserInfo::internal_default_instance());
#else
  user_info_ = const_cast< ::IM::BaseDefine::UserInfo*>(&::IM::BaseDefine::UserInfo::default_instance());
#endif
}

IMValidateRsp::IMValidateRsp(const IMValidateRsp& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMValidateRsp)
}

void IMValidateRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  result_code_ = 0u;
  result_string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_info_ = NULL;
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMValidateRsp::~IMValidateRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMValidateRsp)
  SharedDtor();
}

void IMValidateRsp::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  result_string_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_info_;
  }
}

void IMValidateRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMValidateRsp& IMValidateRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMValidateRsp* IMValidateRsp::default_instance_ = NULL;

IMValidateRsp* IMValidateRsp::New(::google::protobuf::Arena* arena) const {
  IMValidateRsp* n = new IMValidateRsp;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMValidateRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMValidateRsp)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_user_name()) {
      user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    result_code_ = 0u;
    if (has_result_string()) {
      result_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_user_info()) {
      if (user_info_ != NULL) user_info_->::IM::BaseDefine::UserInfo::Clear();
    }
    if (has_attach_data()) {
      attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMValidateRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMValidateRsp, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMValidateRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_result_code;
        break;
      }

      // required uint32 result_code = 2;
      case 2: {
        if (tag == 16) {
         parse_result_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_result_string;
        break;
      }

      // optional string result_string = 3;
      case 3: {
        if (tag == 26) {
         parse_result_string:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_result_string()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_user_info;
        break;
      }

      // optional .IM.BaseDefine.UserInfo user_info = 4;
      case 4: {
        if (tag == 34) {
         parse_user_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMValidateRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMValidateRsp)
  return false;
#undef DO_
}

void IMValidateRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMValidateRsp)
  // required string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->user_name(), output);
  }

  // required uint32 result_code = 2;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->result_code(), output);
  }

  // optional string result_string = 3;
  if (has_result_string()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->result_string(), output);
  }

  // optional .IM.BaseDefine.UserInfo user_info = 4;
  if (has_user_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->user_info_, output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMValidateRsp)
}

int IMValidateRsp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMValidateRsp)
  int total_size = 0;

  if (has_user_name()) {
    // required string user_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->user_name());
  }

  if (has_result_code()) {
    // required uint32 result_code = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->result_code());
  }

  return total_size;
}
int IMValidateRsp::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMValidateRsp)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string user_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->user_name());

    // required uint32 result_code = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->result_code());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[2 / 32] & 28u) {
    // optional string result_string = 3;
    if (has_result_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->result_string());
    }

    // optional .IM.BaseDefine.UserInfo user_info = 4;
    if (has_user_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->user_info_);
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMValidateRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMValidateRsp*>(&from));
}

void IMValidateRsp::MergeFrom(const IMValidateRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMValidateRsp)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_has_user_name();
      user_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_name_);
    }
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_result_string()) {
      set_has_result_string();
      result_string_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.result_string_);
    }
    if (from.has_user_info()) {
      mutable_user_info()->::IM::BaseDefine::UserInfo::MergeFrom(from.user_info());
    }
    if (from.has_attach_data()) {
      set_has_attach_data();
      attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMValidateRsp::CopyFrom(const IMValidateRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMValidateRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMValidateRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_user_info()) {
    if (!this->user_info_->IsInitialized()) return false;
  }
  return true;
}

void IMValidateRsp::Swap(IMValidateRsp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMValidateRsp::InternalSwap(IMValidateRsp* other) {
  user_name_.Swap(&other->user_name_);
  std::swap(result_code_, other->result_code_);
  result_string_.Swap(&other->result_string_);
  std::swap(user_info_, other->user_info_);
  attach_data_.Swap(&other->attach_data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMValidateRsp::GetTypeName() const {
  return "IM.Server.IMValidateRsp";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMValidateRsp

// required string user_name = 1;
bool IMValidateRsp::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IMValidateRsp::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
void IMValidateRsp::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void IMValidateRsp::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_name();
}
 const ::std::string& IMValidateRsp::user_name() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMValidateRsp.user_name)
  return user_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMValidateRsp::set_user_name(const ::std::string& value) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMValidateRsp.user_name)
}
 void IMValidateRsp::set_user_name(const char* value) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMValidateRsp.user_name)
}
 void IMValidateRsp::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMValidateRsp.user_name)
}
 ::std::string* IMValidateRsp::mutable_user_name() {
  set_has_user_name();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMValidateRsp.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMValidateRsp::release_user_name() {
  // @@protoc_insertion_point(field_release:IM.Server.IMValidateRsp.user_name)
  clear_has_user_name();
  return user_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMValidateRsp::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    set_has_user_name();
  } else {
    clear_has_user_name();
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMValidateRsp.user_name)
}

// required uint32 result_code = 2;
bool IMValidateRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IMValidateRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
void IMValidateRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
void IMValidateRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
 ::google::protobuf::uint32 IMValidateRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMValidateRsp.result_code)
  return result_code_;
}
 void IMValidateRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMValidateRsp.result_code)
}

// optional string result_string = 3;
bool IMValidateRsp::has_result_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void IMValidateRsp::set_has_result_string() {
  _has_bits_[0] |= 0x00000004u;
}
void IMValidateRsp::clear_has_result_string() {
  _has_bits_[0] &= ~0x00000004u;
}
void IMValidateRsp::clear_result_string() {
  result_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_result_string();
}
 const ::std::string& IMValidateRsp::result_string() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMValidateRsp.result_string)
  return result_string_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMValidateRsp::set_result_string(const ::std::string& value) {
  set_has_result_string();
  result_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMValidateRsp.result_string)
}
 void IMValidateRsp::set_result_string(const char* value) {
  set_has_result_string();
  result_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMValidateRsp.result_string)
}
 void IMValidateRsp::set_result_string(const char* value, size_t size) {
  set_has_result_string();
  result_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMValidateRsp.result_string)
}
 ::std::string* IMValidateRsp::mutable_result_string() {
  set_has_result_string();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMValidateRsp.result_string)
  return result_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMValidateRsp::release_result_string() {
  // @@protoc_insertion_point(field_release:IM.Server.IMValidateRsp.result_string)
  clear_has_result_string();
  return result_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMValidateRsp::set_allocated_result_string(::std::string* result_string) {
  if (result_string != NULL) {
    set_has_result_string();
  } else {
    clear_has_result_string();
  }
  result_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), result_string);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMValidateRsp.result_string)
}

// optional .IM.BaseDefine.UserInfo user_info = 4;
bool IMValidateRsp::has_user_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void IMValidateRsp::set_has_user_info() {
  _has_bits_[0] |= 0x00000008u;
}
void IMValidateRsp::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000008u;
}
void IMValidateRsp::clear_user_info() {
  if (user_info_ != NULL) user_info_->::IM::BaseDefine::UserInfo::Clear();
  clear_has_user_info();
}
const ::IM::BaseDefine::UserInfo& IMValidateRsp::user_info() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMValidateRsp.user_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_info_ != NULL ? *user_info_ : *default_instance().user_info_;
#else
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
#endif
}
::IM::BaseDefine::UserInfo* IMValidateRsp::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) {
    user_info_ = new ::IM::BaseDefine::UserInfo;
  }
  // @@protoc_insertion_point(field_mutable:IM.Server.IMValidateRsp.user_info)
  return user_info_;
}
::IM::BaseDefine::UserInfo* IMValidateRsp::release_user_info() {
  // @@protoc_insertion_point(field_release:IM.Server.IMValidateRsp.user_info)
  clear_has_user_info();
  ::IM::BaseDefine::UserInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
void IMValidateRsp::set_allocated_user_info(::IM::BaseDefine::UserInfo* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMValidateRsp.user_info)
}

// optional bytes attach_data = 20;
bool IMValidateRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void IMValidateRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
void IMValidateRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
void IMValidateRsp::clear_attach_data() {
  attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attach_data();
}
 const ::std::string& IMValidateRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMValidateRsp.attach_data)
  return attach_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMValidateRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMValidateRsp.attach_data)
}
 void IMValidateRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMValidateRsp.attach_data)
}
 void IMValidateRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMValidateRsp.attach_data)
}
 ::std::string* IMValidateRsp::mutable_attach_data() {
  set_has_attach_data();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMValidateRsp.attach_data)
  return attach_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMValidateRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.Server.IMValidateRsp.attach_data)
  clear_has_attach_data();
  return attach_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMValidateRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data != NULL) {
    set_has_attach_data();
  } else {
    clear_has_attach_data();
  }
  attach_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attach_data);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMValidateRsp.attach_data)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMGetDeviceTokenReq(
    IMGetDeviceTokenReq* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMGetDeviceTokenReq::kUserIdFieldNumber;
const int IMGetDeviceTokenReq::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMGetDeviceTokenReq::IMGetDeviceTokenReq()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGetDeviceTokenReq)
}

void IMGetDeviceTokenReq::InitAsDefaultInstance() {
}

IMGetDeviceTokenReq::IMGetDeviceTokenReq(const IMGetDeviceTokenReq& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGetDeviceTokenReq)
}

void IMGetDeviceTokenReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetDeviceTokenReq::~IMGetDeviceTokenReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGetDeviceTokenReq)
  SharedDtor();
}

void IMGetDeviceTokenReq::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetDeviceTokenReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetDeviceTokenReq& IMGetDeviceTokenReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGetDeviceTokenReq* IMGetDeviceTokenReq::default_instance_ = NULL;

IMGetDeviceTokenReq* IMGetDeviceTokenReq::New(::google::protobuf::Arena* arena) const {
  IMGetDeviceTokenReq* n = new IMGetDeviceTokenReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMGetDeviceTokenReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMGetDeviceTokenReq)
  if (has_attach_data()) {
    attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  user_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMGetDeviceTokenReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMGetDeviceTokenReq, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGetDeviceTokenReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_user_id())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_user_id())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_user_id;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGetDeviceTokenReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGetDeviceTokenReq)
  return false;
#undef DO_
}

void IMGetDeviceTokenReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGetDeviceTokenReq)
  // repeated uint32 user_id = 1;
  for (int i = 0; i < this->user_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->user_id(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGetDeviceTokenReq)
}

int IMGetDeviceTokenReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMGetDeviceTokenReq)
  int total_size = 0;

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->attach_data());
  }

  // repeated uint32 user_id = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->user_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->user_id(i));
    }
    total_size += 1 * this->user_id_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetDeviceTokenReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetDeviceTokenReq*>(&from));
}

void IMGetDeviceTokenReq::MergeFrom(const IMGetDeviceTokenReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMGetDeviceTokenReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  user_id_.MergeFrom(from.user_id_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_attach_data()) {
      set_has_attach_data();
      attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMGetDeviceTokenReq::CopyFrom(const IMGetDeviceTokenReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMGetDeviceTokenReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetDeviceTokenReq::IsInitialized() const {

  return true;
}

void IMGetDeviceTokenReq::Swap(IMGetDeviceTokenReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMGetDeviceTokenReq::InternalSwap(IMGetDeviceTokenReq* other) {
  user_id_.UnsafeArenaSwap(&other->user_id_);
  attach_data_.Swap(&other->attach_data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMGetDeviceTokenReq::GetTypeName() const {
  return "IM.Server.IMGetDeviceTokenReq";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMGetDeviceTokenReq

// repeated uint32 user_id = 1;
int IMGetDeviceTokenReq::user_id_size() const {
  return user_id_.size();
}
void IMGetDeviceTokenReq::clear_user_id() {
  user_id_.Clear();
}
 ::google::protobuf::uint32 IMGetDeviceTokenReq::user_id(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.IMGetDeviceTokenReq.user_id)
  return user_id_.Get(index);
}
 void IMGetDeviceTokenReq::set_user_id(int index, ::google::protobuf::uint32 value) {
  user_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Server.IMGetDeviceTokenReq.user_id)
}
 void IMGetDeviceTokenReq::add_user_id(::google::protobuf::uint32 value) {
  user_id_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Server.IMGetDeviceTokenReq.user_id)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMGetDeviceTokenReq::user_id() const {
  // @@protoc_insertion_point(field_list:IM.Server.IMGetDeviceTokenReq.user_id)
  return user_id_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMGetDeviceTokenReq::mutable_user_id() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.IMGetDeviceTokenReq.user_id)
  return &user_id_;
}

// optional bytes attach_data = 20;
bool IMGetDeviceTokenReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IMGetDeviceTokenReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
void IMGetDeviceTokenReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
void IMGetDeviceTokenReq::clear_attach_data() {
  attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attach_data();
}
 const ::std::string& IMGetDeviceTokenReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMGetDeviceTokenReq.attach_data)
  return attach_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMGetDeviceTokenReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMGetDeviceTokenReq.attach_data)
}
 void IMGetDeviceTokenReq::set_attach_data(const char* value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMGetDeviceTokenReq.attach_data)
}
 void IMGetDeviceTokenReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMGetDeviceTokenReq.attach_data)
}
 ::std::string* IMGetDeviceTokenReq::mutable_attach_data() {
  set_has_attach_data();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMGetDeviceTokenReq.attach_data)
  return attach_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMGetDeviceTokenReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.Server.IMGetDeviceTokenReq.attach_data)
  clear_has_attach_data();
  return attach_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMGetDeviceTokenReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data != NULL) {
    set_has_attach_data();
  } else {
    clear_has_attach_data();
  }
  attach_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attach_data);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMGetDeviceTokenReq.attach_data)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMGetDeviceTokenRsp(
    IMGetDeviceTokenRsp* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMGetDeviceTokenRsp::kUserTokenInfoFieldNumber;
const int IMGetDeviceTokenRsp::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMGetDeviceTokenRsp::IMGetDeviceTokenRsp()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGetDeviceTokenRsp)
}

void IMGetDeviceTokenRsp::InitAsDefaultInstance() {
}

IMGetDeviceTokenRsp::IMGetDeviceTokenRsp(const IMGetDeviceTokenRsp& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGetDeviceTokenRsp)
}

void IMGetDeviceTokenRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetDeviceTokenRsp::~IMGetDeviceTokenRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGetDeviceTokenRsp)
  SharedDtor();
}

void IMGetDeviceTokenRsp::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetDeviceTokenRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetDeviceTokenRsp& IMGetDeviceTokenRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGetDeviceTokenRsp* IMGetDeviceTokenRsp::default_instance_ = NULL;

IMGetDeviceTokenRsp* IMGetDeviceTokenRsp::New(::google::protobuf::Arena* arena) const {
  IMGetDeviceTokenRsp* n = new IMGetDeviceTokenRsp;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMGetDeviceTokenRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMGetDeviceTokenRsp)
  if (has_attach_data()) {
    attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  user_token_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMGetDeviceTokenRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMGetDeviceTokenRsp, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGetDeviceTokenRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.UserTokenInfo user_token_info = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_user_token_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_user_token_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_user_token_info;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGetDeviceTokenRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGetDeviceTokenRsp)
  return false;
#undef DO_
}

void IMGetDeviceTokenRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGetDeviceTokenRsp)
  // repeated .IM.BaseDefine.UserTokenInfo user_token_info = 1;
  for (unsigned int i = 0, n = this->user_token_info_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->user_token_info(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGetDeviceTokenRsp)
}

int IMGetDeviceTokenRsp::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMGetDeviceTokenRsp)
  int total_size = 0;

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->attach_data());
  }

  // repeated .IM.BaseDefine.UserTokenInfo user_token_info = 1;
  total_size += 1 * this->user_token_info_size();
  for (int i = 0; i < this->user_token_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_token_info(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetDeviceTokenRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetDeviceTokenRsp*>(&from));
}

void IMGetDeviceTokenRsp::MergeFrom(const IMGetDeviceTokenRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMGetDeviceTokenRsp)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  user_token_info_.MergeFrom(from.user_token_info_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_attach_data()) {
      set_has_attach_data();
      attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMGetDeviceTokenRsp::CopyFrom(const IMGetDeviceTokenRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMGetDeviceTokenRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetDeviceTokenRsp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->user_token_info())) return false;
  return true;
}

void IMGetDeviceTokenRsp::Swap(IMGetDeviceTokenRsp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMGetDeviceTokenRsp::InternalSwap(IMGetDeviceTokenRsp* other) {
  user_token_info_.UnsafeArenaSwap(&other->user_token_info_);
  attach_data_.Swap(&other->attach_data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMGetDeviceTokenRsp::GetTypeName() const {
  return "IM.Server.IMGetDeviceTokenRsp";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMGetDeviceTokenRsp

// repeated .IM.BaseDefine.UserTokenInfo user_token_info = 1;
int IMGetDeviceTokenRsp::user_token_info_size() const {
  return user_token_info_.size();
}
void IMGetDeviceTokenRsp::clear_user_token_info() {
  user_token_info_.Clear();
}
const ::IM::BaseDefine::UserTokenInfo& IMGetDeviceTokenRsp::user_token_info(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.IMGetDeviceTokenRsp.user_token_info)
  return user_token_info_.Get(index);
}
::IM::BaseDefine::UserTokenInfo* IMGetDeviceTokenRsp::mutable_user_token_info(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Server.IMGetDeviceTokenRsp.user_token_info)
  return user_token_info_.Mutable(index);
}
::IM::BaseDefine::UserTokenInfo* IMGetDeviceTokenRsp::add_user_token_info() {
  // @@protoc_insertion_point(field_add:IM.Server.IMGetDeviceTokenRsp.user_token_info)
  return user_token_info_.Add();
}
::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserTokenInfo >*
IMGetDeviceTokenRsp::mutable_user_token_info() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.IMGetDeviceTokenRsp.user_token_info)
  return &user_token_info_;
}
const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserTokenInfo >&
IMGetDeviceTokenRsp::user_token_info() const {
  // @@protoc_insertion_point(field_list:IM.Server.IMGetDeviceTokenRsp.user_token_info)
  return user_token_info_;
}

// optional bytes attach_data = 20;
bool IMGetDeviceTokenRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IMGetDeviceTokenRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
void IMGetDeviceTokenRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
void IMGetDeviceTokenRsp::clear_attach_data() {
  attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attach_data();
}
 const ::std::string& IMGetDeviceTokenRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMGetDeviceTokenRsp.attach_data)
  return attach_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMGetDeviceTokenRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMGetDeviceTokenRsp.attach_data)
}
 void IMGetDeviceTokenRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMGetDeviceTokenRsp.attach_data)
}
 void IMGetDeviceTokenRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMGetDeviceTokenRsp.attach_data)
}
 ::std::string* IMGetDeviceTokenRsp::mutable_attach_data() {
  set_has_attach_data();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMGetDeviceTokenRsp.attach_data)
  return attach_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMGetDeviceTokenRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.Server.IMGetDeviceTokenRsp.attach_data)
  clear_has_attach_data();
  return attach_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMGetDeviceTokenRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data != NULL) {
    set_has_attach_data();
  } else {
    clear_has_attach_data();
  }
  attach_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attach_data);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMGetDeviceTokenRsp.attach_data)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMRoleSet(
    IMRoleSet* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMRoleSet::kMasterFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMRoleSet::IMRoleSet()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMRoleSet)
}

void IMRoleSet::InitAsDefaultInstance() {
}

IMRoleSet::IMRoleSet(const IMRoleSet& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMRoleSet)
}

void IMRoleSet::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  master_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRoleSet::~IMRoleSet() {
  // @@protoc_insertion_point(destructor:IM.Server.IMRoleSet)
  SharedDtor();
}

void IMRoleSet::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMRoleSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRoleSet& IMRoleSet::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMRoleSet* IMRoleSet::default_instance_ = NULL;

IMRoleSet* IMRoleSet::New(::google::protobuf::Arena* arena) const {
  IMRoleSet* n = new IMRoleSet;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMRoleSet::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMRoleSet)
  master_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMRoleSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMRoleSet, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMRoleSet)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 master = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &master_)));
          set_has_master();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMRoleSet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMRoleSet)
  return false;
#undef DO_
}

void IMRoleSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMRoleSet)
  // required uint32 master = 1;
  if (has_master()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->master(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMRoleSet)
}

int IMRoleSet::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMRoleSet)
  int total_size = 0;

  // required uint32 master = 1;
  if (has_master()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->master());
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRoleSet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRoleSet*>(&from));
}

void IMRoleSet::MergeFrom(const IMRoleSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMRoleSet)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_master()) {
      set_master(from.master());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMRoleSet::CopyFrom(const IMRoleSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMRoleSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRoleSet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMRoleSet::Swap(IMRoleSet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMRoleSet::InternalSwap(IMRoleSet* other) {
  std::swap(master_, other->master_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMRoleSet::GetTypeName() const {
  return "IM.Server.IMRoleSet";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMRoleSet

// required uint32 master = 1;
bool IMRoleSet::has_master() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IMRoleSet::set_has_master() {
  _has_bits_[0] |= 0x00000001u;
}
void IMRoleSet::clear_has_master() {
  _has_bits_[0] &= ~0x00000001u;
}
void IMRoleSet::clear_master() {
  master_ = 0u;
  clear_has_master();
}
 ::google::protobuf::uint32 IMRoleSet::master() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMRoleSet.master)
  return master_;
}
 void IMRoleSet::set_master(::google::protobuf::uint32 value) {
  set_has_master();
  master_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMRoleSet.master)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMOnlineUserInfo(
    IMOnlineUserInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMOnlineUserInfo::kUserStatListFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMOnlineUserInfo::IMOnlineUserInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMOnlineUserInfo)
}

void IMOnlineUserInfo::InitAsDefaultInstance() {
}

IMOnlineUserInfo::IMOnlineUserInfo(const IMOnlineUserInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMOnlineUserInfo)
}

void IMOnlineUserInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMOnlineUserInfo::~IMOnlineUserInfo() {
  // @@protoc_insertion_point(destructor:IM.Server.IMOnlineUserInfo)
  SharedDtor();
}

void IMOnlineUserInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMOnlineUserInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMOnlineUserInfo& IMOnlineUserInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMOnlineUserInfo* IMOnlineUserInfo::default_instance_ = NULL;

IMOnlineUserInfo* IMOnlineUserInfo::New(::google::protobuf::Arena* arena) const {
  IMOnlineUserInfo* n = new IMOnlineUserInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMOnlineUserInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMOnlineUserInfo)
  user_stat_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMOnlineUserInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMOnlineUserInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMOnlineUserInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.ServerUserStat user_stat_list = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_user_stat_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_user_stat_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_user_stat_list;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMOnlineUserInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMOnlineUserInfo)
  return false;
#undef DO_
}

void IMOnlineUserInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMOnlineUserInfo)
  // repeated .IM.BaseDefine.ServerUserStat user_stat_list = 1;
  for (unsigned int i = 0, n = this->user_stat_list_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->user_stat_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMOnlineUserInfo)
}

int IMOnlineUserInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMOnlineUserInfo)
  int total_size = 0;

  // repeated .IM.BaseDefine.ServerUserStat user_stat_list = 1;
  total_size += 1 * this->user_stat_list_size();
  for (int i = 0; i < this->user_stat_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_stat_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMOnlineUserInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMOnlineUserInfo*>(&from));
}

void IMOnlineUserInfo::MergeFrom(const IMOnlineUserInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMOnlineUserInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  user_stat_list_.MergeFrom(from.user_stat_list_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMOnlineUserInfo::CopyFrom(const IMOnlineUserInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMOnlineUserInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMOnlineUserInfo::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->user_stat_list())) return false;
  return true;
}

void IMOnlineUserInfo::Swap(IMOnlineUserInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMOnlineUserInfo::InternalSwap(IMOnlineUserInfo* other) {
  user_stat_list_.UnsafeArenaSwap(&other->user_stat_list_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMOnlineUserInfo::GetTypeName() const {
  return "IM.Server.IMOnlineUserInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMOnlineUserInfo

// repeated .IM.BaseDefine.ServerUserStat user_stat_list = 1;
int IMOnlineUserInfo::user_stat_list_size() const {
  return user_stat_list_.size();
}
void IMOnlineUserInfo::clear_user_stat_list() {
  user_stat_list_.Clear();
}
const ::IM::BaseDefine::ServerUserStat& IMOnlineUserInfo::user_stat_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.IMOnlineUserInfo.user_stat_list)
  return user_stat_list_.Get(index);
}
::IM::BaseDefine::ServerUserStat* IMOnlineUserInfo::mutable_user_stat_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Server.IMOnlineUserInfo.user_stat_list)
  return user_stat_list_.Mutable(index);
}
::IM::BaseDefine::ServerUserStat* IMOnlineUserInfo::add_user_stat_list() {
  // @@protoc_insertion_point(field_add:IM.Server.IMOnlineUserInfo.user_stat_list)
  return user_stat_list_.Add();
}
::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ServerUserStat >*
IMOnlineUserInfo::mutable_user_stat_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.IMOnlineUserInfo.user_stat_list)
  return &user_stat_list_;
}
const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ServerUserStat >&
IMOnlineUserInfo::user_stat_list() const {
  // @@protoc_insertion_point(field_list:IM.Server.IMOnlineUserInfo.user_stat_list)
  return user_stat_list_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMMsgServInfo(
    IMMsgServInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMMsgServInfo::kIp1FieldNumber;
const int IMMsgServInfo::kIp2FieldNumber;
const int IMMsgServInfo::kPortFieldNumber;
const int IMMsgServInfo::kMaxConnCntFieldNumber;
const int IMMsgServInfo::kCurConnCntFieldNumber;
const int IMMsgServInfo::kHostNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMMsgServInfo::IMMsgServInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMMsgServInfo)
}

void IMMsgServInfo::InitAsDefaultInstance() {
}

IMMsgServInfo::IMMsgServInfo(const IMMsgServInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMMsgServInfo)
}

void IMMsgServInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip1_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip2_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0u;
  max_conn_cnt_ = 0u;
  cur_conn_cnt_ = 0u;
  host_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMMsgServInfo::~IMMsgServInfo() {
  // @@protoc_insertion_point(destructor:IM.Server.IMMsgServInfo)
  SharedDtor();
}

void IMMsgServInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip1_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip2_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  host_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMMsgServInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMMsgServInfo& IMMsgServInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMMsgServInfo* IMMsgServInfo::default_instance_ = NULL;

IMMsgServInfo* IMMsgServInfo::New(::google::protobuf::Arena* arena) const {
  IMMsgServInfo* n = new IMMsgServInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMMsgServInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMMsgServInfo)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(IMMsgServInfo, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<IMMsgServInfo*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(port_, max_conn_cnt_);
    if (has_ip1()) {
      ip1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_ip2()) {
      ip2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    cur_conn_cnt_ = 0u;
    if (has_host_name()) {
      host_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMMsgServInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMMsgServInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMMsgServInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ip1 = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip1()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ip2;
        break;
      }

      // required string ip2 = 2;
      case 2: {
        if (tag == 18) {
         parse_ip2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip2()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }

      // required uint32 port = 3;
      case 3: {
        if (tag == 24) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_max_conn_cnt;
        break;
      }

      // required uint32 max_conn_cnt = 4;
      case 4: {
        if (tag == 32) {
         parse_max_conn_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_conn_cnt_)));
          set_has_max_conn_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_cur_conn_cnt;
        break;
      }

      // required uint32 cur_conn_cnt = 5;
      case 5: {
        if (tag == 40) {
         parse_cur_conn_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cur_conn_cnt_)));
          set_has_cur_conn_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_host_name;
        break;
      }

      // required string host_name = 6;
      case 6: {
        if (tag == 50) {
         parse_host_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_host_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMMsgServInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMMsgServInfo)
  return false;
#undef DO_
}

void IMMsgServInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMMsgServInfo)
  // required string ip1 = 1;
  if (has_ip1()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->ip1(), output);
  }

  // required string ip2 = 2;
  if (has_ip2()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ip2(), output);
  }

  // required uint32 port = 3;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->port(), output);
  }

  // required uint32 max_conn_cnt = 4;
  if (has_max_conn_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->max_conn_cnt(), output);
  }

  // required uint32 cur_conn_cnt = 5;
  if (has_cur_conn_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->cur_conn_cnt(), output);
  }

  // required string host_name = 6;
  if (has_host_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->host_name(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMMsgServInfo)
}

int IMMsgServInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMMsgServInfo)
  int total_size = 0;

  if (has_ip1()) {
    // required string ip1 = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ip1());
  }

  if (has_ip2()) {
    // required string ip2 = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ip2());
  }

  if (has_port()) {
    // required uint32 port = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->port());
  }

  if (has_max_conn_cnt()) {
    // required uint32 max_conn_cnt = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->max_conn_cnt());
  }

  if (has_cur_conn_cnt()) {
    // required uint32 cur_conn_cnt = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->cur_conn_cnt());
  }

  if (has_host_name()) {
    // required string host_name = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->host_name());
  }

  return total_size;
}
int IMMsgServInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMMsgServInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required string ip1 = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ip1());

    // required string ip2 = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ip2());

    // required uint32 port = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->port());

    // required uint32 max_conn_cnt = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->max_conn_cnt());

    // required uint32 cur_conn_cnt = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->cur_conn_cnt());

    // required string host_name = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->host_name());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMMsgServInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMMsgServInfo*>(&from));
}

void IMMsgServInfo::MergeFrom(const IMMsgServInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMMsgServInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip1()) {
      set_has_ip1();
      ip1_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip1_);
    }
    if (from.has_ip2()) {
      set_has_ip2();
      ip2_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip2_);
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_max_conn_cnt()) {
      set_max_conn_cnt(from.max_conn_cnt());
    }
    if (from.has_cur_conn_cnt()) {
      set_cur_conn_cnt(from.cur_conn_cnt());
    }
    if (from.has_host_name()) {
      set_has_host_name();
      host_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.host_name_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMMsgServInfo::CopyFrom(const IMMsgServInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMMsgServInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMMsgServInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void IMMsgServInfo::Swap(IMMsgServInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMMsgServInfo::InternalSwap(IMMsgServInfo* other) {
  ip1_.Swap(&other->ip1_);
  ip2_.Swap(&other->ip2_);
  std::swap(port_, other->port_);
  std::swap(max_conn_cnt_, other->max_conn_cnt_);
  std::swap(cur_conn_cnt_, other->cur_conn_cnt_);
  host_name_.Swap(&other->host_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMMsgServInfo::GetTypeName() const {
  return "IM.Server.IMMsgServInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMMsgServInfo

// required string ip1 = 1;
bool IMMsgServInfo::has_ip1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IMMsgServInfo::set_has_ip1() {
  _has_bits_[0] |= 0x00000001u;
}
void IMMsgServInfo::clear_has_ip1() {
  _has_bits_[0] &= ~0x00000001u;
}
void IMMsgServInfo::clear_ip1() {
  ip1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip1();
}
 const ::std::string& IMMsgServInfo::ip1() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMMsgServInfo.ip1)
  return ip1_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMMsgServInfo::set_ip1(const ::std::string& value) {
  set_has_ip1();
  ip1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMMsgServInfo.ip1)
}
 void IMMsgServInfo::set_ip1(const char* value) {
  set_has_ip1();
  ip1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMMsgServInfo.ip1)
}
 void IMMsgServInfo::set_ip1(const char* value, size_t size) {
  set_has_ip1();
  ip1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMMsgServInfo.ip1)
}
 ::std::string* IMMsgServInfo::mutable_ip1() {
  set_has_ip1();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMMsgServInfo.ip1)
  return ip1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMMsgServInfo::release_ip1() {
  // @@protoc_insertion_point(field_release:IM.Server.IMMsgServInfo.ip1)
  clear_has_ip1();
  return ip1_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMMsgServInfo::set_allocated_ip1(::std::string* ip1) {
  if (ip1 != NULL) {
    set_has_ip1();
  } else {
    clear_has_ip1();
  }
  ip1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip1);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMMsgServInfo.ip1)
}

// required string ip2 = 2;
bool IMMsgServInfo::has_ip2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IMMsgServInfo::set_has_ip2() {
  _has_bits_[0] |= 0x00000002u;
}
void IMMsgServInfo::clear_has_ip2() {
  _has_bits_[0] &= ~0x00000002u;
}
void IMMsgServInfo::clear_ip2() {
  ip2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip2();
}
 const ::std::string& IMMsgServInfo::ip2() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMMsgServInfo.ip2)
  return ip2_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMMsgServInfo::set_ip2(const ::std::string& value) {
  set_has_ip2();
  ip2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMMsgServInfo.ip2)
}
 void IMMsgServInfo::set_ip2(const char* value) {
  set_has_ip2();
  ip2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMMsgServInfo.ip2)
}
 void IMMsgServInfo::set_ip2(const char* value, size_t size) {
  set_has_ip2();
  ip2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMMsgServInfo.ip2)
}
 ::std::string* IMMsgServInfo::mutable_ip2() {
  set_has_ip2();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMMsgServInfo.ip2)
  return ip2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMMsgServInfo::release_ip2() {
  // @@protoc_insertion_point(field_release:IM.Server.IMMsgServInfo.ip2)
  clear_has_ip2();
  return ip2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMMsgServInfo::set_allocated_ip2(::std::string* ip2) {
  if (ip2 != NULL) {
    set_has_ip2();
  } else {
    clear_has_ip2();
  }
  ip2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip2);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMMsgServInfo.ip2)
}

// required uint32 port = 3;
bool IMMsgServInfo::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void IMMsgServInfo::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
void IMMsgServInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
void IMMsgServInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
 ::google::protobuf::uint32 IMMsgServInfo::port() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMMsgServInfo.port)
  return port_;
}
 void IMMsgServInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMMsgServInfo.port)
}

// required uint32 max_conn_cnt = 4;
bool IMMsgServInfo::has_max_conn_cnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void IMMsgServInfo::set_has_max_conn_cnt() {
  _has_bits_[0] |= 0x00000008u;
}
void IMMsgServInfo::clear_has_max_conn_cnt() {
  _has_bits_[0] &= ~0x00000008u;
}
void IMMsgServInfo::clear_max_conn_cnt() {
  max_conn_cnt_ = 0u;
  clear_has_max_conn_cnt();
}
 ::google::protobuf::uint32 IMMsgServInfo::max_conn_cnt() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMMsgServInfo.max_conn_cnt)
  return max_conn_cnt_;
}
 void IMMsgServInfo::set_max_conn_cnt(::google::protobuf::uint32 value) {
  set_has_max_conn_cnt();
  max_conn_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMMsgServInfo.max_conn_cnt)
}

// required uint32 cur_conn_cnt = 5;
bool IMMsgServInfo::has_cur_conn_cnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void IMMsgServInfo::set_has_cur_conn_cnt() {
  _has_bits_[0] |= 0x00000010u;
}
void IMMsgServInfo::clear_has_cur_conn_cnt() {
  _has_bits_[0] &= ~0x00000010u;
}
void IMMsgServInfo::clear_cur_conn_cnt() {
  cur_conn_cnt_ = 0u;
  clear_has_cur_conn_cnt();
}
 ::google::protobuf::uint32 IMMsgServInfo::cur_conn_cnt() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMMsgServInfo.cur_conn_cnt)
  return cur_conn_cnt_;
}
 void IMMsgServInfo::set_cur_conn_cnt(::google::protobuf::uint32 value) {
  set_has_cur_conn_cnt();
  cur_conn_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMMsgServInfo.cur_conn_cnt)
}

// required string host_name = 6;
bool IMMsgServInfo::has_host_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void IMMsgServInfo::set_has_host_name() {
  _has_bits_[0] |= 0x00000020u;
}
void IMMsgServInfo::clear_has_host_name() {
  _has_bits_[0] &= ~0x00000020u;
}
void IMMsgServInfo::clear_host_name() {
  host_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host_name();
}
 const ::std::string& IMMsgServInfo::host_name() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMMsgServInfo.host_name)
  return host_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMMsgServInfo::set_host_name(const ::std::string& value) {
  set_has_host_name();
  host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMMsgServInfo.host_name)
}
 void IMMsgServInfo::set_host_name(const char* value) {
  set_has_host_name();
  host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMMsgServInfo.host_name)
}
 void IMMsgServInfo::set_host_name(const char* value, size_t size) {
  set_has_host_name();
  host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMMsgServInfo.host_name)
}
 ::std::string* IMMsgServInfo::mutable_host_name() {
  set_has_host_name();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMMsgServInfo.host_name)
  return host_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMMsgServInfo::release_host_name() {
  // @@protoc_insertion_point(field_release:IM.Server.IMMsgServInfo.host_name)
  clear_has_host_name();
  return host_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMMsgServInfo::set_allocated_host_name(::std::string* host_name) {
  if (host_name != NULL) {
    set_has_host_name();
  } else {
    clear_has_host_name();
  }
  host_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_name);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMMsgServInfo.host_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMUserStatusUpdate(
    IMUserStatusUpdate* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMUserStatusUpdate::kUserStatusFieldNumber;
const int IMUserStatusUpdate::kUserIdFieldNumber;
const int IMUserStatusUpdate::kClientTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMUserStatusUpdate::IMUserStatusUpdate()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMUserStatusUpdate)
}

void IMUserStatusUpdate::InitAsDefaultInstance() {
}

IMUserStatusUpdate::IMUserStatusUpdate(const IMUserStatusUpdate& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMUserStatusUpdate)
}

void IMUserStatusUpdate::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_status_ = 0u;
  user_id_ = 0u;
  client_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMUserStatusUpdate::~IMUserStatusUpdate() {
  // @@protoc_insertion_point(destructor:IM.Server.IMUserStatusUpdate)
  SharedDtor();
}

void IMUserStatusUpdate::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMUserStatusUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMUserStatusUpdate& IMUserStatusUpdate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMUserStatusUpdate* IMUserStatusUpdate::default_instance_ = NULL;

IMUserStatusUpdate* IMUserStatusUpdate::New(::google::protobuf::Arena* arena) const {
  IMUserStatusUpdate* n = new IMUserStatusUpdate;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMUserStatusUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMUserStatusUpdate)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(IMUserStatusUpdate, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<IMUserStatusUpdate*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(user_status_, user_id_);
    client_type_ = 1;
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMUserStatusUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMUserStatusUpdate, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMUserStatusUpdate)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_status = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_status_)));
          set_has_user_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_client_type;
        break;
      }

      // required .IM.BaseDefine.ClientType client_type = 3;
      case 3: {
        if (tag == 24) {
         parse_client_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_client_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMUserStatusUpdate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMUserStatusUpdate)
  return false;
#undef DO_
}

void IMUserStatusUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMUserStatusUpdate)
  // required uint32 user_status = 1;
  if (has_user_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_status(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required .IM.BaseDefine.ClientType client_type = 3;
  if (has_client_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->client_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMUserStatusUpdate)
}

int IMUserStatusUpdate::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMUserStatusUpdate)
  int total_size = 0;

  if (has_user_status()) {
    // required uint32 user_status = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_status());
  }

  if (has_user_id()) {
    // required uint32 user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());
  }

  if (has_client_type()) {
    // required .IM.BaseDefine.ClientType client_type = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());
  }

  return total_size;
}
int IMUserStatusUpdate::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMUserStatusUpdate)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 user_status = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_status());

    // required uint32 user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());

    // required .IM.BaseDefine.ClientType client_type = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMUserStatusUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMUserStatusUpdate*>(&from));
}

void IMUserStatusUpdate::MergeFrom(const IMUserStatusUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMUserStatusUpdate)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_status()) {
      set_user_status(from.user_status());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_client_type()) {
      set_client_type(from.client_type());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMUserStatusUpdate::CopyFrom(const IMUserStatusUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMUserStatusUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUserStatusUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMUserStatusUpdate::Swap(IMUserStatusUpdate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMUserStatusUpdate::InternalSwap(IMUserStatusUpdate* other) {
  std::swap(user_status_, other->user_status_);
  std::swap(user_id_, other->user_id_);
  std::swap(client_type_, other->client_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMUserStatusUpdate::GetTypeName() const {
  return "IM.Server.IMUserStatusUpdate";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMUserStatusUpdate

// required uint32 user_status = 1;
bool IMUserStatusUpdate::has_user_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IMUserStatusUpdate::set_has_user_status() {
  _has_bits_[0] |= 0x00000001u;
}
void IMUserStatusUpdate::clear_has_user_status() {
  _has_bits_[0] &= ~0x00000001u;
}
void IMUserStatusUpdate::clear_user_status() {
  user_status_ = 0u;
  clear_has_user_status();
}
 ::google::protobuf::uint32 IMUserStatusUpdate::user_status() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMUserStatusUpdate.user_status)
  return user_status_;
}
 void IMUserStatusUpdate::set_user_status(::google::protobuf::uint32 value) {
  set_has_user_status();
  user_status_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMUserStatusUpdate.user_status)
}

// required uint32 user_id = 2;
bool IMUserStatusUpdate::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IMUserStatusUpdate::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
void IMUserStatusUpdate::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void IMUserStatusUpdate::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
 ::google::protobuf::uint32 IMUserStatusUpdate::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMUserStatusUpdate.user_id)
  return user_id_;
}
 void IMUserStatusUpdate::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMUserStatusUpdate.user_id)
}

// required .IM.BaseDefine.ClientType client_type = 3;
bool IMUserStatusUpdate::has_client_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void IMUserStatusUpdate::set_has_client_type() {
  _has_bits_[0] |= 0x00000004u;
}
void IMUserStatusUpdate::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000004u;
}
void IMUserStatusUpdate::clear_client_type() {
  client_type_ = 1;
  clear_has_client_type();
}
 ::IM::BaseDefine::ClientType IMUserStatusUpdate::client_type() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMUserStatusUpdate.client_type)
  return static_cast< ::IM::BaseDefine::ClientType >(client_type_);
}
 void IMUserStatusUpdate::set_client_type(::IM::BaseDefine::ClientType value) {
  assert(::IM::BaseDefine::ClientType_IsValid(value));
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMUserStatusUpdate.client_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMUserCntUpdate(
    IMUserCntUpdate* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMUserCntUpdate::kUserActionFieldNumber;
const int IMUserCntUpdate::kUserIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMUserCntUpdate::IMUserCntUpdate()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMUserCntUpdate)
}

void IMUserCntUpdate::InitAsDefaultInstance() {
}

IMUserCntUpdate::IMUserCntUpdate(const IMUserCntUpdate& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMUserCntUpdate)
}

void IMUserCntUpdate::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_action_ = 0u;
  user_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMUserCntUpdate::~IMUserCntUpdate() {
  // @@protoc_insertion_point(destructor:IM.Server.IMUserCntUpdate)
  SharedDtor();
}

void IMUserCntUpdate::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMUserCntUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMUserCntUpdate& IMUserCntUpdate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMUserCntUpdate* IMUserCntUpdate::default_instance_ = NULL;

IMUserCntUpdate* IMUserCntUpdate::New(::google::protobuf::Arena* arena) const {
  IMUserCntUpdate* n = new IMUserCntUpdate;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMUserCntUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMUserCntUpdate)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(IMUserCntUpdate, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<IMUserCntUpdate*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(user_action_, user_id_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMUserCntUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMUserCntUpdate, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMUserCntUpdate)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_action = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_action_)));
          set_has_user_action();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMUserCntUpdate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMUserCntUpdate)
  return false;
#undef DO_
}

void IMUserCntUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMUserCntUpdate)
  // required uint32 user_action = 1;
  if (has_user_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_action(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMUserCntUpdate)
}

int IMUserCntUpdate::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMUserCntUpdate)
  int total_size = 0;

  if (has_user_action()) {
    // required uint32 user_action = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_action());
  }

  if (has_user_id()) {
    // required uint32 user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());
  }

  return total_size;
}
int IMUserCntUpdate::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMUserCntUpdate)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 user_action = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_action());

    // required uint32 user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMUserCntUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMUserCntUpdate*>(&from));
}

void IMUserCntUpdate::MergeFrom(const IMUserCntUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMUserCntUpdate)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_action()) {
      set_user_action(from.user_action());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMUserCntUpdate::CopyFrom(const IMUserCntUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMUserCntUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUserCntUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMUserCntUpdate::Swap(IMUserCntUpdate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMUserCntUpdate::InternalSwap(IMUserCntUpdate* other) {
  std::swap(user_action_, other->user_action_);
  std::swap(user_id_, other->user_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMUserCntUpdate::GetTypeName() const {
  return "IM.Server.IMUserCntUpdate";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMUserCntUpdate

// required uint32 user_action = 1;
bool IMUserCntUpdate::has_user_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IMUserCntUpdate::set_has_user_action() {
  _has_bits_[0] |= 0x00000001u;
}
void IMUserCntUpdate::clear_has_user_action() {
  _has_bits_[0] &= ~0x00000001u;
}
void IMUserCntUpdate::clear_user_action() {
  user_action_ = 0u;
  clear_has_user_action();
}
 ::google::protobuf::uint32 IMUserCntUpdate::user_action() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMUserCntUpdate.user_action)
  return user_action_;
}
 void IMUserCntUpdate::set_user_action(::google::protobuf::uint32 value) {
  set_has_user_action();
  user_action_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMUserCntUpdate.user_action)
}

// required uint32 user_id = 2;
bool IMUserCntUpdate::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IMUserCntUpdate::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
void IMUserCntUpdate::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void IMUserCntUpdate::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
 ::google::protobuf::uint32 IMUserCntUpdate::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMUserCntUpdate.user_id)
  return user_id_;
}
 void IMUserCntUpdate::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMUserCntUpdate.user_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMServerKickUser(
    IMServerKickUser* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMServerKickUser::kUserIdFieldNumber;
const int IMServerKickUser::kClientTypeFieldNumber;
const int IMServerKickUser::kReasonFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMServerKickUser::IMServerKickUser()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMServerKickUser)
}

void IMServerKickUser::InitAsDefaultInstance() {
}

IMServerKickUser::IMServerKickUser(const IMServerKickUser& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMServerKickUser)
}

void IMServerKickUser::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_id_ = 0u;
  client_type_ = 1;
  reason_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMServerKickUser::~IMServerKickUser() {
  // @@protoc_insertion_point(destructor:IM.Server.IMServerKickUser)
  SharedDtor();
}

void IMServerKickUser::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMServerKickUser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMServerKickUser& IMServerKickUser::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMServerKickUser* IMServerKickUser::default_instance_ = NULL;

IMServerKickUser* IMServerKickUser::New(::google::protobuf::Arena* arena) const {
  IMServerKickUser* n = new IMServerKickUser;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMServerKickUser::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMServerKickUser)
  if (_has_bits_[0 / 32] & 7u) {
    user_id_ = 0u;
    client_type_ = 1;
    reason_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMServerKickUser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMServerKickUser, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMServerKickUser)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_client_type;
        break;
      }

      // required .IM.BaseDefine.ClientType client_type = 2;
      case 2: {
        if (tag == 16) {
         parse_client_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_client_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_reason;
        break;
      }

      // required uint32 reason = 3;
      case 3: {
        if (tag == 24) {
         parse_reason:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reason_)));
          set_has_reason();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMServerKickUser)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMServerKickUser)
  return false;
#undef DO_
}

void IMServerKickUser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMServerKickUser)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required .IM.BaseDefine.ClientType client_type = 2;
  if (has_client_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->client_type(), output);
  }

  // required uint32 reason = 3;
  if (has_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->reason(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMServerKickUser)
}

int IMServerKickUser::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMServerKickUser)
  int total_size = 0;

  if (has_user_id()) {
    // required uint32 user_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());
  }

  if (has_client_type()) {
    // required .IM.BaseDefine.ClientType client_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());
  }

  if (has_reason()) {
    // required uint32 reason = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->reason());
  }

  return total_size;
}
int IMServerKickUser::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMServerKickUser)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());

    // required .IM.BaseDefine.ClientType client_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());

    // required uint32 reason = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->reason());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMServerKickUser::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMServerKickUser*>(&from));
}

void IMServerKickUser::MergeFrom(const IMServerKickUser& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMServerKickUser)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_client_type()) {
      set_client_type(from.client_type());
    }
    if (from.has_reason()) {
      set_reason(from.reason());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMServerKickUser::CopyFrom(const IMServerKickUser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMServerKickUser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMServerKickUser::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMServerKickUser::Swap(IMServerKickUser* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMServerKickUser::InternalSwap(IMServerKickUser* other) {
  std::swap(user_id_, other->user_id_);
  std::swap(client_type_, other->client_type_);
  std::swap(reason_, other->reason_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMServerKickUser::GetTypeName() const {
  return "IM.Server.IMServerKickUser";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMServerKickUser

// required uint32 user_id = 1;
bool IMServerKickUser::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IMServerKickUser::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
void IMServerKickUser::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void IMServerKickUser::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
 ::google::protobuf::uint32 IMServerKickUser::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMServerKickUser.user_id)
  return user_id_;
}
 void IMServerKickUser::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMServerKickUser.user_id)
}

// required .IM.BaseDefine.ClientType client_type = 2;
bool IMServerKickUser::has_client_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IMServerKickUser::set_has_client_type() {
  _has_bits_[0] |= 0x00000002u;
}
void IMServerKickUser::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void IMServerKickUser::clear_client_type() {
  client_type_ = 1;
  clear_has_client_type();
}
 ::IM::BaseDefine::ClientType IMServerKickUser::client_type() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMServerKickUser.client_type)
  return static_cast< ::IM::BaseDefine::ClientType >(client_type_);
}
 void IMServerKickUser::set_client_type(::IM::BaseDefine::ClientType value) {
  assert(::IM::BaseDefine::ClientType_IsValid(value));
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMServerKickUser.client_type)
}

// required uint32 reason = 3;
bool IMServerKickUser::has_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void IMServerKickUser::set_has_reason() {
  _has_bits_[0] |= 0x00000004u;
}
void IMServerKickUser::clear_has_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
void IMServerKickUser::clear_reason() {
  reason_ = 0u;
  clear_has_reason();
}
 ::google::protobuf::uint32 IMServerKickUser::reason() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMServerKickUser.reason)
  return reason_;
}
 void IMServerKickUser::set_reason(::google::protobuf::uint32 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMServerKickUser.reason)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMServerPCLoginStatusNotify(
    IMServerPCLoginStatusNotify* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMServerPCLoginStatusNotify::kUserIdFieldNumber;
const int IMServerPCLoginStatusNotify::kLoginStatusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMServerPCLoginStatusNotify::IMServerPCLoginStatusNotify()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMServerPCLoginStatusNotify)
}

void IMServerPCLoginStatusNotify::InitAsDefaultInstance() {
}

IMServerPCLoginStatusNotify::IMServerPCLoginStatusNotify(const IMServerPCLoginStatusNotify& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMServerPCLoginStatusNotify)
}

void IMServerPCLoginStatusNotify::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_id_ = 0u;
  login_status_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMServerPCLoginStatusNotify::~IMServerPCLoginStatusNotify() {
  // @@protoc_insertion_point(destructor:IM.Server.IMServerPCLoginStatusNotify)
  SharedDtor();
}

void IMServerPCLoginStatusNotify::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMServerPCLoginStatusNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMServerPCLoginStatusNotify& IMServerPCLoginStatusNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMServerPCLoginStatusNotify* IMServerPCLoginStatusNotify::default_instance_ = NULL;

IMServerPCLoginStatusNotify* IMServerPCLoginStatusNotify::New(::google::protobuf::Arena* arena) const {
  IMServerPCLoginStatusNotify* n = new IMServerPCLoginStatusNotify;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMServerPCLoginStatusNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMServerPCLoginStatusNotify)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(IMServerPCLoginStatusNotify, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<IMServerPCLoginStatusNotify*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(user_id_, login_status_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMServerPCLoginStatusNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMServerPCLoginStatusNotify, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMServerPCLoginStatusNotify)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_login_status;
        break;
      }

      // required uint32 login_status = 2;
      case 2: {
        if (tag == 16) {
         parse_login_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &login_status_)));
          set_has_login_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMServerPCLoginStatusNotify)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMServerPCLoginStatusNotify)
  return false;
#undef DO_
}

void IMServerPCLoginStatusNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMServerPCLoginStatusNotify)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 login_status = 2;
  if (has_login_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->login_status(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMServerPCLoginStatusNotify)
}

int IMServerPCLoginStatusNotify::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMServerPCLoginStatusNotify)
  int total_size = 0;

  if (has_user_id()) {
    // required uint32 user_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());
  }

  if (has_login_status()) {
    // required uint32 login_status = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->login_status());
  }

  return total_size;
}
int IMServerPCLoginStatusNotify::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMServerPCLoginStatusNotify)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());

    // required uint32 login_status = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->login_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMServerPCLoginStatusNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMServerPCLoginStatusNotify*>(&from));
}

void IMServerPCLoginStatusNotify::MergeFrom(const IMServerPCLoginStatusNotify& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMServerPCLoginStatusNotify)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_login_status()) {
      set_login_status(from.login_status());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMServerPCLoginStatusNotify::CopyFrom(const IMServerPCLoginStatusNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMServerPCLoginStatusNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMServerPCLoginStatusNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMServerPCLoginStatusNotify::Swap(IMServerPCLoginStatusNotify* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMServerPCLoginStatusNotify::InternalSwap(IMServerPCLoginStatusNotify* other) {
  std::swap(user_id_, other->user_id_);
  std::swap(login_status_, other->login_status_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMServerPCLoginStatusNotify::GetTypeName() const {
  return "IM.Server.IMServerPCLoginStatusNotify";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMServerPCLoginStatusNotify

// required uint32 user_id = 1;
bool IMServerPCLoginStatusNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IMServerPCLoginStatusNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
void IMServerPCLoginStatusNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void IMServerPCLoginStatusNotify::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
 ::google::protobuf::uint32 IMServerPCLoginStatusNotify::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMServerPCLoginStatusNotify.user_id)
  return user_id_;
}
 void IMServerPCLoginStatusNotify::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMServerPCLoginStatusNotify.user_id)
}

// required uint32 login_status = 2;
bool IMServerPCLoginStatusNotify::has_login_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IMServerPCLoginStatusNotify::set_has_login_status() {
  _has_bits_[0] |= 0x00000002u;
}
void IMServerPCLoginStatusNotify::clear_has_login_status() {
  _has_bits_[0] &= ~0x00000002u;
}
void IMServerPCLoginStatusNotify::clear_login_status() {
  login_status_ = 0u;
  clear_has_login_status();
}
 ::google::protobuf::uint32 IMServerPCLoginStatusNotify::login_status() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMServerPCLoginStatusNotify.login_status)
  return login_status_;
}
 void IMServerPCLoginStatusNotify::set_login_status(::google::protobuf::uint32 value) {
  set_has_login_status();
  login_status_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMServerPCLoginStatusNotify.login_status)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMPushToUserReq(
    IMPushToUserReq* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMPushToUserReq::kFlashFieldNumber;
const int IMPushToUserReq::kDataFieldNumber;
const int IMPushToUserReq::kUserTokenListFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMPushToUserReq::IMPushToUserReq()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMPushToUserReq)
}

void IMPushToUserReq::InitAsDefaultInstance() {
}

IMPushToUserReq::IMPushToUserReq(const IMPushToUserReq& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMPushToUserReq)
}

void IMPushToUserReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  flash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMPushToUserReq::~IMPushToUserReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMPushToUserReq)
  SharedDtor();
}

void IMPushToUserReq::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  flash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMPushToUserReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMPushToUserReq& IMPushToUserReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMPushToUserReq* IMPushToUserReq::default_instance_ = NULL;

IMPushToUserReq* IMPushToUserReq::New(::google::protobuf::Arena* arena) const {
  IMPushToUserReq* n = new IMPushToUserReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMPushToUserReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMPushToUserReq)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_flash()) {
      flash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_data()) {
      data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  user_token_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMPushToUserReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMPushToUserReq, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMPushToUserReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string flash = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_flash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // required string data = 2;
      case 2: {
        if (tag == 18) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_user_token_list;
        break;
      }

      // repeated .IM.BaseDefine.UserTokenInfo user_token_list = 3;
      case 3: {
        if (tag == 26) {
         parse_user_token_list:
          DO_(input->IncrementRecursionDepth());
         parse_loop_user_token_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_user_token_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_user_token_list;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMPushToUserReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMPushToUserReq)
  return false;
#undef DO_
}

void IMPushToUserReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMPushToUserReq)
  // required string flash = 1;
  if (has_flash()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->flash(), output);
  }

  // required string data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->data(), output);
  }

  // repeated .IM.BaseDefine.UserTokenInfo user_token_list = 3;
  for (unsigned int i = 0, n = this->user_token_list_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->user_token_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMPushToUserReq)
}

int IMPushToUserReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMPushToUserReq)
  int total_size = 0;

  if (has_flash()) {
    // required string flash = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->flash());
  }

  if (has_data()) {
    // required string data = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->data());
  }

  return total_size;
}
int IMPushToUserReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMPushToUserReq)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string flash = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->flash());

    // required string data = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->data());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated .IM.BaseDefine.UserTokenInfo user_token_list = 3;
  total_size += 1 * this->user_token_list_size();
  for (int i = 0; i < this->user_token_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_token_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMPushToUserReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMPushToUserReq*>(&from));
}

void IMPushToUserReq::MergeFrom(const IMPushToUserReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMPushToUserReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  user_token_list_.MergeFrom(from.user_token_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_flash()) {
      set_has_flash();
      flash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.flash_);
    }
    if (from.has_data()) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMPushToUserReq::CopyFrom(const IMPushToUserReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMPushToUserReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMPushToUserReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->user_token_list())) return false;
  return true;
}

void IMPushToUserReq::Swap(IMPushToUserReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMPushToUserReq::InternalSwap(IMPushToUserReq* other) {
  flash_.Swap(&other->flash_);
  data_.Swap(&other->data_);
  user_token_list_.UnsafeArenaSwap(&other->user_token_list_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMPushToUserReq::GetTypeName() const {
  return "IM.Server.IMPushToUserReq";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMPushToUserReq

// required string flash = 1;
bool IMPushToUserReq::has_flash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IMPushToUserReq::set_has_flash() {
  _has_bits_[0] |= 0x00000001u;
}
void IMPushToUserReq::clear_has_flash() {
  _has_bits_[0] &= ~0x00000001u;
}
void IMPushToUserReq::clear_flash() {
  flash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_flash();
}
 const ::std::string& IMPushToUserReq::flash() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMPushToUserReq.flash)
  return flash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMPushToUserReq::set_flash(const ::std::string& value) {
  set_has_flash();
  flash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMPushToUserReq.flash)
}
 void IMPushToUserReq::set_flash(const char* value) {
  set_has_flash();
  flash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMPushToUserReq.flash)
}
 void IMPushToUserReq::set_flash(const char* value, size_t size) {
  set_has_flash();
  flash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMPushToUserReq.flash)
}
 ::std::string* IMPushToUserReq::mutable_flash() {
  set_has_flash();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMPushToUserReq.flash)
  return flash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMPushToUserReq::release_flash() {
  // @@protoc_insertion_point(field_release:IM.Server.IMPushToUserReq.flash)
  clear_has_flash();
  return flash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMPushToUserReq::set_allocated_flash(::std::string* flash) {
  if (flash != NULL) {
    set_has_flash();
  } else {
    clear_has_flash();
  }
  flash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), flash);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMPushToUserReq.flash)
}

// required string data = 2;
bool IMPushToUserReq::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IMPushToUserReq::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
void IMPushToUserReq::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
void IMPushToUserReq::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
 const ::std::string& IMPushToUserReq::data() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMPushToUserReq.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMPushToUserReq::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMPushToUserReq.data)
}
 void IMPushToUserReq::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMPushToUserReq.data)
}
 void IMPushToUserReq::set_data(const char* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMPushToUserReq.data)
}
 ::std::string* IMPushToUserReq::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMPushToUserReq.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMPushToUserReq::release_data() {
  // @@protoc_insertion_point(field_release:IM.Server.IMPushToUserReq.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMPushToUserReq::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMPushToUserReq.data)
}

// repeated .IM.BaseDefine.UserTokenInfo user_token_list = 3;
int IMPushToUserReq::user_token_list_size() const {
  return user_token_list_.size();
}
void IMPushToUserReq::clear_user_token_list() {
  user_token_list_.Clear();
}
const ::IM::BaseDefine::UserTokenInfo& IMPushToUserReq::user_token_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.IMPushToUserReq.user_token_list)
  return user_token_list_.Get(index);
}
::IM::BaseDefine::UserTokenInfo* IMPushToUserReq::mutable_user_token_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Server.IMPushToUserReq.user_token_list)
  return user_token_list_.Mutable(index);
}
::IM::BaseDefine::UserTokenInfo* IMPushToUserReq::add_user_token_list() {
  // @@protoc_insertion_point(field_add:IM.Server.IMPushToUserReq.user_token_list)
  return user_token_list_.Add();
}
::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserTokenInfo >*
IMPushToUserReq::mutable_user_token_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.IMPushToUserReq.user_token_list)
  return &user_token_list_;
}
const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserTokenInfo >&
IMPushToUserReq::user_token_list() const {
  // @@protoc_insertion_point(field_list:IM.Server.IMPushToUserReq.user_token_list)
  return user_token_list_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMPushToUserRsp(
    IMPushToUserRsp* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMPushToUserRsp::kPushResultListFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMPushToUserRsp::IMPushToUserRsp()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMPushToUserRsp)
}

void IMPushToUserRsp::InitAsDefaultInstance() {
}

IMPushToUserRsp::IMPushToUserRsp(const IMPushToUserRsp& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMPushToUserRsp)
}

void IMPushToUserRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMPushToUserRsp::~IMPushToUserRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMPushToUserRsp)
  SharedDtor();
}

void IMPushToUserRsp::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMPushToUserRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMPushToUserRsp& IMPushToUserRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMPushToUserRsp* IMPushToUserRsp::default_instance_ = NULL;

IMPushToUserRsp* IMPushToUserRsp::New(::google::protobuf::Arena* arena) const {
  IMPushToUserRsp* n = new IMPushToUserRsp;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMPushToUserRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMPushToUserRsp)
  push_result_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMPushToUserRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMPushToUserRsp, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMPushToUserRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.PushResult push_result_list = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_push_result_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_push_result_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_push_result_list;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMPushToUserRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMPushToUserRsp)
  return false;
#undef DO_
}

void IMPushToUserRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMPushToUserRsp)
  // repeated .IM.BaseDefine.PushResult push_result_list = 1;
  for (unsigned int i = 0, n = this->push_result_list_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->push_result_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMPushToUserRsp)
}

int IMPushToUserRsp::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMPushToUserRsp)
  int total_size = 0;

  // repeated .IM.BaseDefine.PushResult push_result_list = 1;
  total_size += 1 * this->push_result_list_size();
  for (int i = 0; i < this->push_result_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->push_result_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMPushToUserRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMPushToUserRsp*>(&from));
}

void IMPushToUserRsp::MergeFrom(const IMPushToUserRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMPushToUserRsp)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  push_result_list_.MergeFrom(from.push_result_list_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMPushToUserRsp::CopyFrom(const IMPushToUserRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMPushToUserRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMPushToUserRsp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->push_result_list())) return false;
  return true;
}

void IMPushToUserRsp::Swap(IMPushToUserRsp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMPushToUserRsp::InternalSwap(IMPushToUserRsp* other) {
  push_result_list_.UnsafeArenaSwap(&other->push_result_list_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMPushToUserRsp::GetTypeName() const {
  return "IM.Server.IMPushToUserRsp";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMPushToUserRsp

// repeated .IM.BaseDefine.PushResult push_result_list = 1;
int IMPushToUserRsp::push_result_list_size() const {
  return push_result_list_.size();
}
void IMPushToUserRsp::clear_push_result_list() {
  push_result_list_.Clear();
}
const ::IM::BaseDefine::PushResult& IMPushToUserRsp::push_result_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.IMPushToUserRsp.push_result_list)
  return push_result_list_.Get(index);
}
::IM::BaseDefine::PushResult* IMPushToUserRsp::mutable_push_result_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Server.IMPushToUserRsp.push_result_list)
  return push_result_list_.Mutable(index);
}
::IM::BaseDefine::PushResult* IMPushToUserRsp::add_push_result_list() {
  // @@protoc_insertion_point(field_add:IM.Server.IMPushToUserRsp.push_result_list)
  return push_result_list_.Add();
}
::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::PushResult >*
IMPushToUserRsp::mutable_push_result_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.IMPushToUserRsp.push_result_list)
  return &push_result_list_;
}
const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::PushResult >&
IMPushToUserRsp::push_result_list() const {
  // @@protoc_insertion_point(field_list:IM.Server.IMPushToUserRsp.push_result_list)
  return push_result_list_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMGroupGetShieldReq(
    IMGroupGetShieldReq* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMGroupGetShieldReq::kGroupIdFieldNumber;
const int IMGroupGetShieldReq::kUserIdFieldNumber;
const int IMGroupGetShieldReq::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMGroupGetShieldReq::IMGroupGetShieldReq()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGroupGetShieldReq)
}

void IMGroupGetShieldReq::InitAsDefaultInstance() {
}

IMGroupGetShieldReq::IMGroupGetShieldReq(const IMGroupGetShieldReq& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGroupGetShieldReq)
}

void IMGroupGetShieldReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  group_id_ = 0u;
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGroupGetShieldReq::~IMGroupGetShieldReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGroupGetShieldReq)
  SharedDtor();
}

void IMGroupGetShieldReq::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGroupGetShieldReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGroupGetShieldReq& IMGroupGetShieldReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGroupGetShieldReq* IMGroupGetShieldReq::default_instance_ = NULL;

IMGroupGetShieldReq* IMGroupGetShieldReq::New(::google::protobuf::Arena* arena) const {
  IMGroupGetShieldReq* n = new IMGroupGetShieldReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMGroupGetShieldReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMGroupGetShieldReq)
  if (_has_bits_[0 / 32] & 5u) {
    group_id_ = 0u;
    if (has_attach_data()) {
      attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  user_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMGroupGetShieldReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMGroupGetShieldReq, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGroupGetShieldReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // repeated uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_user_id())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_user_id())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGroupGetShieldReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGroupGetShieldReq)
  return false;
#undef DO_
}

void IMGroupGetShieldReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGroupGetShieldReq)
  // required uint32 group_id = 1;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // repeated uint32 user_id = 2;
  for (int i = 0; i < this->user_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->user_id(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGroupGetShieldReq)
}

int IMGroupGetShieldReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMGroupGetShieldReq)
  int total_size = 0;

  // required uint32 group_id = 1;
  if (has_group_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->group_id());
  }
  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->attach_data());
  }

  // repeated uint32 user_id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->user_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->user_id(i));
    }
    total_size += 1 * this->user_id_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGroupGetShieldReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGroupGetShieldReq*>(&from));
}

void IMGroupGetShieldReq::MergeFrom(const IMGroupGetShieldReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMGroupGetShieldReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  user_id_.MergeFrom(from.user_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_attach_data()) {
      set_has_attach_data();
      attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMGroupGetShieldReq::CopyFrom(const IMGroupGetShieldReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMGroupGetShieldReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGroupGetShieldReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMGroupGetShieldReq::Swap(IMGroupGetShieldReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMGroupGetShieldReq::InternalSwap(IMGroupGetShieldReq* other) {
  std::swap(group_id_, other->group_id_);
  user_id_.UnsafeArenaSwap(&other->user_id_);
  attach_data_.Swap(&other->attach_data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMGroupGetShieldReq::GetTypeName() const {
  return "IM.Server.IMGroupGetShieldReq";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMGroupGetShieldReq

// required uint32 group_id = 1;
bool IMGroupGetShieldReq::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IMGroupGetShieldReq::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
void IMGroupGetShieldReq::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void IMGroupGetShieldReq::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
 ::google::protobuf::uint32 IMGroupGetShieldReq::group_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMGroupGetShieldReq.group_id)
  return group_id_;
}
 void IMGroupGetShieldReq::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMGroupGetShieldReq.group_id)
}

// repeated uint32 user_id = 2;
int IMGroupGetShieldReq::user_id_size() const {
  return user_id_.size();
}
void IMGroupGetShieldReq::clear_user_id() {
  user_id_.Clear();
}
 ::google::protobuf::uint32 IMGroupGetShieldReq::user_id(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.IMGroupGetShieldReq.user_id)
  return user_id_.Get(index);
}
 void IMGroupGetShieldReq::set_user_id(int index, ::google::protobuf::uint32 value) {
  user_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Server.IMGroupGetShieldReq.user_id)
}
 void IMGroupGetShieldReq::add_user_id(::google::protobuf::uint32 value) {
  user_id_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Server.IMGroupGetShieldReq.user_id)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMGroupGetShieldReq::user_id() const {
  // @@protoc_insertion_point(field_list:IM.Server.IMGroupGetShieldReq.user_id)
  return user_id_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMGroupGetShieldReq::mutable_user_id() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.IMGroupGetShieldReq.user_id)
  return &user_id_;
}

// optional bytes attach_data = 20;
bool IMGroupGetShieldReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void IMGroupGetShieldReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
void IMGroupGetShieldReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
void IMGroupGetShieldReq::clear_attach_data() {
  attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attach_data();
}
 const ::std::string& IMGroupGetShieldReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMGroupGetShieldReq.attach_data)
  return attach_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMGroupGetShieldReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMGroupGetShieldReq.attach_data)
}
 void IMGroupGetShieldReq::set_attach_data(const char* value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMGroupGetShieldReq.attach_data)
}
 void IMGroupGetShieldReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMGroupGetShieldReq.attach_data)
}
 ::std::string* IMGroupGetShieldReq::mutable_attach_data() {
  set_has_attach_data();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMGroupGetShieldReq.attach_data)
  return attach_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMGroupGetShieldReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.Server.IMGroupGetShieldReq.attach_data)
  clear_has_attach_data();
  return attach_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMGroupGetShieldReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data != NULL) {
    set_has_attach_data();
  } else {
    clear_has_attach_data();
  }
  attach_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attach_data);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMGroupGetShieldReq.attach_data)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMGroupGetShieldRsp(
    IMGroupGetShieldRsp* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMGroupGetShieldRsp::kGroupIdFieldNumber;
const int IMGroupGetShieldRsp::kShieldStatusListFieldNumber;
const int IMGroupGetShieldRsp::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMGroupGetShieldRsp::IMGroupGetShieldRsp()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGroupGetShieldRsp)
}

void IMGroupGetShieldRsp::InitAsDefaultInstance() {
}

IMGroupGetShieldRsp::IMGroupGetShieldRsp(const IMGroupGetShieldRsp& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGroupGetShieldRsp)
}

void IMGroupGetShieldRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  group_id_ = 0u;
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGroupGetShieldRsp::~IMGroupGetShieldRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGroupGetShieldRsp)
  SharedDtor();
}

void IMGroupGetShieldRsp::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGroupGetShieldRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGroupGetShieldRsp& IMGroupGetShieldRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGroupGetShieldRsp* IMGroupGetShieldRsp::default_instance_ = NULL;

IMGroupGetShieldRsp* IMGroupGetShieldRsp::New(::google::protobuf::Arena* arena) const {
  IMGroupGetShieldRsp* n = new IMGroupGetShieldRsp;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMGroupGetShieldRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMGroupGetShieldRsp)
  if (_has_bits_[0 / 32] & 5u) {
    group_id_ = 0u;
    if (has_attach_data()) {
      attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  shield_status_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMGroupGetShieldRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMGroupGetShieldRsp, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGroupGetShieldRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_shield_status_list;
        break;
      }

      // repeated .IM.BaseDefine.ShieldStatus shield_status_list = 2;
      case 2: {
        if (tag == 18) {
         parse_shield_status_list:
          DO_(input->IncrementRecursionDepth());
         parse_loop_shield_status_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_shield_status_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_shield_status_list;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGroupGetShieldRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGroupGetShieldRsp)
  return false;
#undef DO_
}

void IMGroupGetShieldRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGroupGetShieldRsp)
  // required uint32 group_id = 1;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // repeated .IM.BaseDefine.ShieldStatus shield_status_list = 2;
  for (unsigned int i = 0, n = this->shield_status_list_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->shield_status_list(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGroupGetShieldRsp)
}

int IMGroupGetShieldRsp::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMGroupGetShieldRsp)
  int total_size = 0;

  // required uint32 group_id = 1;
  if (has_group_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->group_id());
  }
  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->attach_data());
  }

  // repeated .IM.BaseDefine.ShieldStatus shield_status_list = 2;
  total_size += 1 * this->shield_status_list_size();
  for (int i = 0; i < this->shield_status_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->shield_status_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGroupGetShieldRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGroupGetShieldRsp*>(&from));
}

void IMGroupGetShieldRsp::MergeFrom(const IMGroupGetShieldRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMGroupGetShieldRsp)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  shield_status_list_.MergeFrom(from.shield_status_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_attach_data()) {
      set_has_attach_data();
      attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMGroupGetShieldRsp::CopyFrom(const IMGroupGetShieldRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMGroupGetShieldRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGroupGetShieldRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->shield_status_list())) return false;
  return true;
}

void IMGroupGetShieldRsp::Swap(IMGroupGetShieldRsp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMGroupGetShieldRsp::InternalSwap(IMGroupGetShieldRsp* other) {
  std::swap(group_id_, other->group_id_);
  shield_status_list_.UnsafeArenaSwap(&other->shield_status_list_);
  attach_data_.Swap(&other->attach_data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMGroupGetShieldRsp::GetTypeName() const {
  return "IM.Server.IMGroupGetShieldRsp";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMGroupGetShieldRsp

// required uint32 group_id = 1;
bool IMGroupGetShieldRsp::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IMGroupGetShieldRsp::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
void IMGroupGetShieldRsp::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void IMGroupGetShieldRsp::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
 ::google::protobuf::uint32 IMGroupGetShieldRsp::group_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMGroupGetShieldRsp.group_id)
  return group_id_;
}
 void IMGroupGetShieldRsp::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMGroupGetShieldRsp.group_id)
}

// repeated .IM.BaseDefine.ShieldStatus shield_status_list = 2;
int IMGroupGetShieldRsp::shield_status_list_size() const {
  return shield_status_list_.size();
}
void IMGroupGetShieldRsp::clear_shield_status_list() {
  shield_status_list_.Clear();
}
const ::IM::BaseDefine::ShieldStatus& IMGroupGetShieldRsp::shield_status_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.IMGroupGetShieldRsp.shield_status_list)
  return shield_status_list_.Get(index);
}
::IM::BaseDefine::ShieldStatus* IMGroupGetShieldRsp::mutable_shield_status_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Server.IMGroupGetShieldRsp.shield_status_list)
  return shield_status_list_.Mutable(index);
}
::IM::BaseDefine::ShieldStatus* IMGroupGetShieldRsp::add_shield_status_list() {
  // @@protoc_insertion_point(field_add:IM.Server.IMGroupGetShieldRsp.shield_status_list)
  return shield_status_list_.Add();
}
::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ShieldStatus >*
IMGroupGetShieldRsp::mutable_shield_status_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.IMGroupGetShieldRsp.shield_status_list)
  return &shield_status_list_;
}
const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ShieldStatus >&
IMGroupGetShieldRsp::shield_status_list() const {
  // @@protoc_insertion_point(field_list:IM.Server.IMGroupGetShieldRsp.shield_status_list)
  return shield_status_list_;
}

// optional bytes attach_data = 20;
bool IMGroupGetShieldRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void IMGroupGetShieldRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
void IMGroupGetShieldRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
void IMGroupGetShieldRsp::clear_attach_data() {
  attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attach_data();
}
 const ::std::string& IMGroupGetShieldRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMGroupGetShieldRsp.attach_data)
  return attach_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMGroupGetShieldRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMGroupGetShieldRsp.attach_data)
}
 void IMGroupGetShieldRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMGroupGetShieldRsp.attach_data)
}
 void IMGroupGetShieldRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMGroupGetShieldRsp.attach_data)
}
 ::std::string* IMGroupGetShieldRsp::mutable_attach_data() {
  set_has_attach_data();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMGroupGetShieldRsp.attach_data)
  return attach_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMGroupGetShieldRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.Server.IMGroupGetShieldRsp.attach_data)
  clear_has_attach_data();
  return attach_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMGroupGetShieldRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data != NULL) {
    set_has_attach_data();
  } else {
    clear_has_attach_data();
  }
  attach_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attach_data);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMGroupGetShieldRsp.attach_data)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMFileTransferReq(
    IMFileTransferReq* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMFileTransferReq::kFromUserIdFieldNumber;
const int IMFileTransferReq::kToUserIdFieldNumber;
const int IMFileTransferReq::kFileNameFieldNumber;
const int IMFileTransferReq::kFileSizeFieldNumber;
const int IMFileTransferReq::kTransModeFieldNumber;
const int IMFileTransferReq::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMFileTransferReq::IMFileTransferReq()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMFileTransferReq)
}

void IMFileTransferReq::InitAsDefaultInstance() {
}

IMFileTransferReq::IMFileTransferReq(const IMFileTransferReq& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMFileTransferReq)
}

void IMFileTransferReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  from_user_id_ = 0u;
  to_user_id_ = 0u;
  file_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_size_ = 0u;
  trans_mode_ = 1;
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileTransferReq::~IMFileTransferReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMFileTransferReq)
  SharedDtor();
}

void IMFileTransferReq::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMFileTransferReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileTransferReq& IMFileTransferReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMFileTransferReq* IMFileTransferReq::default_instance_ = NULL;

IMFileTransferReq* IMFileTransferReq::New(::google::protobuf::Arena* arena) const {
  IMFileTransferReq* n = new IMFileTransferReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMFileTransferReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMFileTransferReq)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(IMFileTransferReq, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<IMFileTransferReq*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(from_user_id_, to_user_id_);
    if (has_file_name()) {
      file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    file_size_ = 0u;
    trans_mode_ = 1;
    if (has_attach_data()) {
      attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMFileTransferReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMFileTransferReq, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMFileTransferReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_to_user_id;
        break;
      }

      // required uint32 to_user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_file_name;
        break;
      }

      // required string file_name = 3;
      case 3: {
        if (tag == 26) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_file_size;
        break;
      }

      // required uint32 file_size = 4;
      case 4: {
        if (tag == 32) {
         parse_file_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_size_)));
          set_has_file_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_trans_mode;
        break;
      }

      // required .IM.BaseDefine.TransferFileType trans_mode = 5;
      case 5: {
        if (tag == 40) {
         parse_trans_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::TransferFileType_IsValid(value)) {
            set_trans_mode(static_cast< ::IM::BaseDefine::TransferFileType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(40);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMFileTransferReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMFileTransferReq)
  return false;
#undef DO_
}

void IMFileTransferReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMFileTransferReq)
  // required uint32 from_user_id = 1;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_user_id(), output);
  }

  // required uint32 to_user_id = 2;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->to_user_id(), output);
  }

  // required string file_name = 3;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->file_name(), output);
  }

  // required uint32 file_size = 4;
  if (has_file_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->file_size(), output);
  }

  // required .IM.BaseDefine.TransferFileType trans_mode = 5;
  if (has_trans_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->trans_mode(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMFileTransferReq)
}

int IMFileTransferReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMFileTransferReq)
  int total_size = 0;

  if (has_from_user_id()) {
    // required uint32 from_user_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->from_user_id());
  }

  if (has_to_user_id()) {
    // required uint32 to_user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->to_user_id());
  }

  if (has_file_name()) {
    // required string file_name = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->file_name());
  }

  if (has_file_size()) {
    // required uint32 file_size = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->file_size());
  }

  if (has_trans_mode()) {
    // required .IM.BaseDefine.TransferFileType trans_mode = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_mode());
  }

  return total_size;
}
int IMFileTransferReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMFileTransferReq)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required uint32 from_user_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->from_user_id());

    // required uint32 to_user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->to_user_id());

    // required string file_name = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->file_name());

    // required uint32 file_size = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->file_size());

    // required .IM.BaseDefine.TransferFileType trans_mode = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_mode());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->attach_data());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileTransferReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileTransferReq*>(&from));
}

void IMFileTransferReq::MergeFrom(const IMFileTransferReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMFileTransferReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_file_name()) {
      set_has_file_name();
      file_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.file_name_);
    }
    if (from.has_file_size()) {
      set_file_size(from.file_size());
    }
    if (from.has_trans_mode()) {
      set_trans_mode(from.trans_mode());
    }
    if (from.has_attach_data()) {
      set_has_attach_data();
      attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMFileTransferReq::CopyFrom(const IMFileTransferReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMFileTransferReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileTransferReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void IMFileTransferReq::Swap(IMFileTransferReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMFileTransferReq::InternalSwap(IMFileTransferReq* other) {
  std::swap(from_user_id_, other->from_user_id_);
  std::swap(to_user_id_, other->to_user_id_);
  file_name_.Swap(&other->file_name_);
  std::swap(file_size_, other->file_size_);
  std::swap(trans_mode_, other->trans_mode_);
  attach_data_.Swap(&other->attach_data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMFileTransferReq::GetTypeName() const {
  return "IM.Server.IMFileTransferReq";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMFileTransferReq

// required uint32 from_user_id = 1;
bool IMFileTransferReq::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IMFileTransferReq::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
void IMFileTransferReq::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void IMFileTransferReq::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
 ::google::protobuf::uint32 IMFileTransferReq::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileTransferReq.from_user_id)
  return from_user_id_;
}
 void IMFileTransferReq::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMFileTransferReq.from_user_id)
}

// required uint32 to_user_id = 2;
bool IMFileTransferReq::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IMFileTransferReq::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
void IMFileTransferReq::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void IMFileTransferReq::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
 ::google::protobuf::uint32 IMFileTransferReq::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileTransferReq.to_user_id)
  return to_user_id_;
}
 void IMFileTransferReq::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMFileTransferReq.to_user_id)
}

// required string file_name = 3;
bool IMFileTransferReq::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void IMFileTransferReq::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
void IMFileTransferReq::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
void IMFileTransferReq::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
 const ::std::string& IMFileTransferReq::file_name() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileTransferReq.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMFileTransferReq::set_file_name(const ::std::string& value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMFileTransferReq.file_name)
}
 void IMFileTransferReq::set_file_name(const char* value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMFileTransferReq.file_name)
}
 void IMFileTransferReq::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMFileTransferReq.file_name)
}
 ::std::string* IMFileTransferReq::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMFileTransferReq.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMFileTransferReq::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.Server.IMFileTransferReq.file_name)
  clear_has_file_name();
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMFileTransferReq::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMFileTransferReq.file_name)
}

// required uint32 file_size = 4;
bool IMFileTransferReq::has_file_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void IMFileTransferReq::set_has_file_size() {
  _has_bits_[0] |= 0x00000008u;
}
void IMFileTransferReq::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000008u;
}
void IMFileTransferReq::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
 ::google::protobuf::uint32 IMFileTransferReq::file_size() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileTransferReq.file_size)
  return file_size_;
}
 void IMFileTransferReq::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMFileTransferReq.file_size)
}

// required .IM.BaseDefine.TransferFileType trans_mode = 5;
bool IMFileTransferReq::has_trans_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void IMFileTransferReq::set_has_trans_mode() {
  _has_bits_[0] |= 0x00000010u;
}
void IMFileTransferReq::clear_has_trans_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
void IMFileTransferReq::clear_trans_mode() {
  trans_mode_ = 1;
  clear_has_trans_mode();
}
 ::IM::BaseDefine::TransferFileType IMFileTransferReq::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileTransferReq.trans_mode)
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
 void IMFileTransferReq::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  assert(::IM::BaseDefine::TransferFileType_IsValid(value));
  set_has_trans_mode();
  trans_mode_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMFileTransferReq.trans_mode)
}

// optional bytes attach_data = 20;
bool IMFileTransferReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void IMFileTransferReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000020u;
}
void IMFileTransferReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000020u;
}
void IMFileTransferReq::clear_attach_data() {
  attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attach_data();
}
 const ::std::string& IMFileTransferReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileTransferReq.attach_data)
  return attach_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMFileTransferReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMFileTransferReq.attach_data)
}
 void IMFileTransferReq::set_attach_data(const char* value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMFileTransferReq.attach_data)
}
 void IMFileTransferReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMFileTransferReq.attach_data)
}
 ::std::string* IMFileTransferReq::mutable_attach_data() {
  set_has_attach_data();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMFileTransferReq.attach_data)
  return attach_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMFileTransferReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.Server.IMFileTransferReq.attach_data)
  clear_has_attach_data();
  return attach_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMFileTransferReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data != NULL) {
    set_has_attach_data();
  } else {
    clear_has_attach_data();
  }
  attach_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attach_data);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMFileTransferReq.attach_data)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMFileTransferRsp(
    IMFileTransferRsp* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMFileTransferRsp::kResultCodeFieldNumber;
const int IMFileTransferRsp::kFromUserIdFieldNumber;
const int IMFileTransferRsp::kToUserIdFieldNumber;
const int IMFileTransferRsp::kFileNameFieldNumber;
const int IMFileTransferRsp::kFileSizeFieldNumber;
const int IMFileTransferRsp::kTaskIdFieldNumber;
const int IMFileTransferRsp::kTransModeFieldNumber;
const int IMFileTransferRsp::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMFileTransferRsp::IMFileTransferRsp()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMFileTransferRsp)
}

void IMFileTransferRsp::InitAsDefaultInstance() {
}

IMFileTransferRsp::IMFileTransferRsp(const IMFileTransferRsp& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMFileTransferRsp)
}

void IMFileTransferRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  result_code_ = 0u;
  from_user_id_ = 0u;
  to_user_id_ = 0u;
  file_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_size_ = 0u;
  task_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trans_mode_ = 1;
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileTransferRsp::~IMFileTransferRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMFileTransferRsp)
  SharedDtor();
}

void IMFileTransferRsp::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  task_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMFileTransferRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileTransferRsp& IMFileTransferRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMFileTransferRsp* IMFileTransferRsp::default_instance_ = NULL;

IMFileTransferRsp* IMFileTransferRsp::New(::google::protobuf::Arena* arena) const {
  IMFileTransferRsp* n = new IMFileTransferRsp;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMFileTransferRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMFileTransferRsp)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(IMFileTransferRsp, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<IMFileTransferRsp*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(result_code_, from_user_id_);
    ZR_(to_user_id_, file_size_);
    if (has_file_name()) {
      file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_task_id()) {
      task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    trans_mode_ = 1;
    if (has_attach_data()) {
      attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMFileTransferRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMFileTransferRsp, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMFileTransferRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 result_code = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_from_user_id;
        break;
      }

      // required uint32 from_user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_to_user_id;
        break;
      }

      // required uint32 to_user_id = 3;
      case 3: {
        if (tag == 24) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_file_name;
        break;
      }

      // optional string file_name = 4;
      case 4: {
        if (tag == 34) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_file_size;
        break;
      }

      // optional uint32 file_size = 5;
      case 5: {
        if (tag == 40) {
         parse_file_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_size_)));
          set_has_file_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_task_id;
        break;
      }

      // optional string task_id = 6;
      case 6: {
        if (tag == 50) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_trans_mode;
        break;
      }

      // optional .IM.BaseDefine.TransferFileType trans_mode = 7;
      case 7: {
        if (tag == 56) {
         parse_trans_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::TransferFileType_IsValid(value)) {
            set_trans_mode(static_cast< ::IM::BaseDefine::TransferFileType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(56);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMFileTransferRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMFileTransferRsp)
  return false;
#undef DO_
}

void IMFileTransferRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMFileTransferRsp)
  // required uint32 result_code = 1;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->result_code(), output);
  }

  // required uint32 from_user_id = 2;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_user_id(), output);
  }

  // required uint32 to_user_id = 3;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->to_user_id(), output);
  }

  // optional string file_name = 4;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->file_name(), output);
  }

  // optional uint32 file_size = 5;
  if (has_file_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->file_size(), output);
  }

  // optional string task_id = 6;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->task_id(), output);
  }

  // optional .IM.BaseDefine.TransferFileType trans_mode = 7;
  if (has_trans_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->trans_mode(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMFileTransferRsp)
}

int IMFileTransferRsp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMFileTransferRsp)
  int total_size = 0;

  if (has_result_code()) {
    // required uint32 result_code = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->result_code());
  }

  if (has_from_user_id()) {
    // required uint32 from_user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->from_user_id());
  }

  if (has_to_user_id()) {
    // required uint32 to_user_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->to_user_id());
  }

  return total_size;
}
int IMFileTransferRsp::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMFileTransferRsp)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 result_code = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->result_code());

    // required uint32 from_user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->from_user_id());

    // required uint32 to_user_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->to_user_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[3 / 32] & 248u) {
    // optional string file_name = 4;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }

    // optional uint32 file_size = 5;
    if (has_file_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_size());
    }

    // optional string task_id = 6;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }

    // optional .IM.BaseDefine.TransferFileType trans_mode = 7;
    if (has_trans_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_mode());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileTransferRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileTransferRsp*>(&from));
}

void IMFileTransferRsp::MergeFrom(const IMFileTransferRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMFileTransferRsp)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_file_name()) {
      set_has_file_name();
      file_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.file_name_);
    }
    if (from.has_file_size()) {
      set_file_size(from.file_size());
    }
    if (from.has_task_id()) {
      set_has_task_id();
      task_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.task_id_);
    }
    if (from.has_trans_mode()) {
      set_trans_mode(from.trans_mode());
    }
    if (from.has_attach_data()) {
      set_has_attach_data();
      attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMFileTransferRsp::CopyFrom(const IMFileTransferRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMFileTransferRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileTransferRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMFileTransferRsp::Swap(IMFileTransferRsp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMFileTransferRsp::InternalSwap(IMFileTransferRsp* other) {
  std::swap(result_code_, other->result_code_);
  std::swap(from_user_id_, other->from_user_id_);
  std::swap(to_user_id_, other->to_user_id_);
  file_name_.Swap(&other->file_name_);
  std::swap(file_size_, other->file_size_);
  task_id_.Swap(&other->task_id_);
  std::swap(trans_mode_, other->trans_mode_);
  attach_data_.Swap(&other->attach_data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMFileTransferRsp::GetTypeName() const {
  return "IM.Server.IMFileTransferRsp";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMFileTransferRsp

// required uint32 result_code = 1;
bool IMFileTransferRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IMFileTransferRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000001u;
}
void IMFileTransferRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000001u;
}
void IMFileTransferRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
 ::google::protobuf::uint32 IMFileTransferRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileTransferRsp.result_code)
  return result_code_;
}
 void IMFileTransferRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMFileTransferRsp.result_code)
}

// required uint32 from_user_id = 2;
bool IMFileTransferRsp::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IMFileTransferRsp::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
void IMFileTransferRsp::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void IMFileTransferRsp::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
 ::google::protobuf::uint32 IMFileTransferRsp::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileTransferRsp.from_user_id)
  return from_user_id_;
}
 void IMFileTransferRsp::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMFileTransferRsp.from_user_id)
}

// required uint32 to_user_id = 3;
bool IMFileTransferRsp::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void IMFileTransferRsp::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
void IMFileTransferRsp::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void IMFileTransferRsp::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
 ::google::protobuf::uint32 IMFileTransferRsp::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileTransferRsp.to_user_id)
  return to_user_id_;
}
 void IMFileTransferRsp::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMFileTransferRsp.to_user_id)
}

// optional string file_name = 4;
bool IMFileTransferRsp::has_file_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void IMFileTransferRsp::set_has_file_name() {
  _has_bits_[0] |= 0x00000008u;
}
void IMFileTransferRsp::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000008u;
}
void IMFileTransferRsp::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
 const ::std::string& IMFileTransferRsp::file_name() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileTransferRsp.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMFileTransferRsp::set_file_name(const ::std::string& value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMFileTransferRsp.file_name)
}
 void IMFileTransferRsp::set_file_name(const char* value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMFileTransferRsp.file_name)
}
 void IMFileTransferRsp::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMFileTransferRsp.file_name)
}
 ::std::string* IMFileTransferRsp::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMFileTransferRsp.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMFileTransferRsp::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.Server.IMFileTransferRsp.file_name)
  clear_has_file_name();
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMFileTransferRsp::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMFileTransferRsp.file_name)
}

// optional uint32 file_size = 5;
bool IMFileTransferRsp::has_file_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void IMFileTransferRsp::set_has_file_size() {
  _has_bits_[0] |= 0x00000010u;
}
void IMFileTransferRsp::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000010u;
}
void IMFileTransferRsp::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
 ::google::protobuf::uint32 IMFileTransferRsp::file_size() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileTransferRsp.file_size)
  return file_size_;
}
 void IMFileTransferRsp::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMFileTransferRsp.file_size)
}

// optional string task_id = 6;
bool IMFileTransferRsp::has_task_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void IMFileTransferRsp::set_has_task_id() {
  _has_bits_[0] |= 0x00000020u;
}
void IMFileTransferRsp::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000020u;
}
void IMFileTransferRsp::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
 const ::std::string& IMFileTransferRsp::task_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileTransferRsp.task_id)
  return task_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMFileTransferRsp::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMFileTransferRsp.task_id)
}
 void IMFileTransferRsp::set_task_id(const char* value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMFileTransferRsp.task_id)
}
 void IMFileTransferRsp::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMFileTransferRsp.task_id)
}
 ::std::string* IMFileTransferRsp::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMFileTransferRsp.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMFileTransferRsp::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.Server.IMFileTransferRsp.task_id)
  clear_has_task_id();
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMFileTransferRsp::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMFileTransferRsp.task_id)
}

// optional .IM.BaseDefine.TransferFileType trans_mode = 7;
bool IMFileTransferRsp::has_trans_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void IMFileTransferRsp::set_has_trans_mode() {
  _has_bits_[0] |= 0x00000040u;
}
void IMFileTransferRsp::clear_has_trans_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
void IMFileTransferRsp::clear_trans_mode() {
  trans_mode_ = 1;
  clear_has_trans_mode();
}
 ::IM::BaseDefine::TransferFileType IMFileTransferRsp::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileTransferRsp.trans_mode)
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
 void IMFileTransferRsp::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  assert(::IM::BaseDefine::TransferFileType_IsValid(value));
  set_has_trans_mode();
  trans_mode_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.IMFileTransferRsp.trans_mode)
}

// optional bytes attach_data = 20;
bool IMFileTransferRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void IMFileTransferRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000080u;
}
void IMFileTransferRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000080u;
}
void IMFileTransferRsp::clear_attach_data() {
  attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attach_data();
}
 const ::std::string& IMFileTransferRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileTransferRsp.attach_data)
  return attach_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMFileTransferRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.Server.IMFileTransferRsp.attach_data)
}
 void IMFileTransferRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.Server.IMFileTransferRsp.attach_data)
}
 void IMFileTransferRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.Server.IMFileTransferRsp.attach_data)
}
 ::std::string* IMFileTransferRsp::mutable_attach_data() {
  set_has_attach_data();
  // @@protoc_insertion_point(field_mutable:IM.Server.IMFileTransferRsp.attach_data)
  return attach_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* IMFileTransferRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.Server.IMFileTransferRsp.attach_data)
  clear_has_attach_data();
  return attach_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void IMFileTransferRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data != NULL) {
    set_has_attach_data();
  } else {
    clear_has_attach_data();
  }
  attach_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attach_data);
  // @@protoc_insertion_point(field_set_allocated:IM.Server.IMFileTransferRsp.attach_data)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMFileServerIPReq(
    IMFileServerIPReq* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMFileServerIPReq::IMFileServerIPReq()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMFileServerIPReq)
}

void IMFileServerIPReq::InitAsDefaultInstance() {
}

IMFileServerIPReq::IMFileServerIPReq(const IMFileServerIPReq& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMFileServerIPReq)
}

void IMFileServerIPReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileServerIPReq::~IMFileServerIPReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMFileServerIPReq)
  SharedDtor();
}

void IMFileServerIPReq::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMFileServerIPReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileServerIPReq& IMFileServerIPReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMFileServerIPReq* IMFileServerIPReq::default_instance_ = NULL;

IMFileServerIPReq* IMFileServerIPReq::New(::google::protobuf::Arena* arena) const {
  IMFileServerIPReq* n = new IMFileServerIPReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMFileServerIPReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMFileServerIPReq)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMFileServerIPReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMFileServerIPReq, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMFileServerIPReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMFileServerIPReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMFileServerIPReq)
  return false;
#undef DO_
}

void IMFileServerIPReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMFileServerIPReq)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMFileServerIPReq)
}

int IMFileServerIPReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMFileServerIPReq)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileServerIPReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileServerIPReq*>(&from));
}

void IMFileServerIPReq::MergeFrom(const IMFileServerIPReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMFileServerIPReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMFileServerIPReq::CopyFrom(const IMFileServerIPReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMFileServerIPReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileServerIPReq::IsInitialized() const {

  return true;
}

void IMFileServerIPReq::Swap(IMFileServerIPReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMFileServerIPReq::InternalSwap(IMFileServerIPReq* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMFileServerIPReq::GetTypeName() const {
  return "IM.Server.IMFileServerIPReq";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMFileServerIPReq

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIMFileServerIPRsp(
    IMFileServerIPRsp* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMFileServerIPRsp::kIpAddrListFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMFileServerIPRsp::IMFileServerIPRsp()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMFileServerIPRsp)
}

void IMFileServerIPRsp::InitAsDefaultInstance() {
}

IMFileServerIPRsp::IMFileServerIPRsp(const IMFileServerIPRsp& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMFileServerIPRsp)
}

void IMFileServerIPRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileServerIPRsp::~IMFileServerIPRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMFileServerIPRsp)
  SharedDtor();
}

void IMFileServerIPRsp::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMFileServerIPRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileServerIPRsp& IMFileServerIPRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMFileServerIPRsp* IMFileServerIPRsp::default_instance_ = NULL;

IMFileServerIPRsp* IMFileServerIPRsp::New(::google::protobuf::Arena* arena) const {
  IMFileServerIPRsp* n = new IMFileServerIPRsp;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IMFileServerIPRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMFileServerIPRsp)
  ip_addr_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IMFileServerIPRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForIMFileServerIPRsp, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMFileServerIPRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.IpAddr ip_addr_list = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_ip_addr_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_ip_addr_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_ip_addr_list;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMFileServerIPRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMFileServerIPRsp)
  return false;
#undef DO_
}

void IMFileServerIPRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMFileServerIPRsp)
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 1;
  for (unsigned int i = 0, n = this->ip_addr_list_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->ip_addr_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMFileServerIPRsp)
}

int IMFileServerIPRsp::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMFileServerIPRsp)
  int total_size = 0;

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 1;
  total_size += 1 * this->ip_addr_list_size();
  for (int i = 0; i < this->ip_addr_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ip_addr_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileServerIPRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileServerIPRsp*>(&from));
}

void IMFileServerIPRsp::MergeFrom(const IMFileServerIPRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMFileServerIPRsp)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  ip_addr_list_.MergeFrom(from.ip_addr_list_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IMFileServerIPRsp::CopyFrom(const IMFileServerIPRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMFileServerIPRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileServerIPRsp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->ip_addr_list())) return false;
  return true;
}

void IMFileServerIPRsp::Swap(IMFileServerIPRsp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMFileServerIPRsp::InternalSwap(IMFileServerIPRsp* other) {
  ip_addr_list_.UnsafeArenaSwap(&other->ip_addr_list_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IMFileServerIPRsp::GetTypeName() const {
  return "IM.Server.IMFileServerIPRsp";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IMFileServerIPRsp

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 1;
int IMFileServerIPRsp::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
void IMFileServerIPRsp::clear_ip_addr_list() {
  ip_addr_list_.Clear();
}
const ::IM::BaseDefine::IpAddr& IMFileServerIPRsp::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.IMFileServerIPRsp.ip_addr_list)
  return ip_addr_list_.Get(index);
}
::IM::BaseDefine::IpAddr* IMFileServerIPRsp::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Server.IMFileServerIPRsp.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
::IM::BaseDefine::IpAddr* IMFileServerIPRsp::add_ip_addr_list() {
  // @@protoc_insertion_point(field_add:IM.Server.IMFileServerIPRsp.ip_addr_list)
  return ip_addr_list_.Add();
}
::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileServerIPRsp::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.IMFileServerIPRsp.ip_addr_list)
  return &ip_addr_list_;
}
const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileServerIPRsp::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:IM.Server.IMFileServerIPRsp.ip_addr_list)
  return ip_addr_list_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace Server
}  // namespace IM

// @@protoc_insertion_point(global_scope)
